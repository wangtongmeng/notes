import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.C5rzuSi5.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe/interview/公司面试/雄安产业互联.md","filePath":"fe/interview/公司面试/雄安产业互联.md","lastUpdated":1699236651000}'),p={name:"fe/interview/公司面试/雄安产业互联.md"},e=n(`<p>1.Es6 里面class原理 类和java的类有什么区别 2.Web socket开发 3.修饰器 4.Vue2基础知识，组件封装 5.兄弟组件之间如何通信 6.Webpack相关知识 7.Css :em rem px vh vw简单说下 8.vue.use 9.Canvas绘制 VUE3是否用过开发项目，及基础知识，与VUE2有什么区别，做了哪些优化和改进？ E-chart的使用 可视化 大屏的自适应 VUEX、 elementUI 三次握手，四次挥手</p><p>Cookie有哪些属性 事件流 协商缓存 跨域 接收报错</p><h2 id="es6-里面class原理-类和java的类有什么区别" tabindex="-1">Es6 里面class原理 类和java的类有什么区别 <a class="header-anchor" href="#es6-里面class原理-类和java的类有什么区别" aria-label="Permalink to &quot;Es6 里面class原理 类和java的类有什么区别&quot;">​</a></h2><p>在ES6（ECMAScript 2015）中，引入了新的语法特性，其中包括了类（class）。类是一种用于创建对象的模板，它定义了对象的属性和方法。</p><p>在ES6之前，JavaScript使用原型继承来实现对象的创建和继承。使用原型继承时，需要通过构造函数来创建对象，并通过原型链实现继承。ES6中的类提供了一种更简洁、清晰的方式来定义对象和实现继承。</p><p>类的原理可以归结为以下几个关键点：</p><ol><li><p>类声明： 使用<code>class</code>关键字来声明一个类。类名通常使用大写字母开头，按照命名约定使用驼峰式命名法。例如：</p><p>javascript</p><p>复制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class MyClass {</span></span>
<span class="line"><span>  // 类的定义</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>\`\`\`</span></span></code></pre></div></li><li><p>构造函数： 类可以包含一个特殊的方法，称为构造函数（constructor）。构造函数通过<code>constructor</code>关键字定义，用于创建和初始化对象。构造函数在使用<code>new</code>关键字创建类的实例时自动调用。例如：</p><p>javascript</p><p>复制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class MyClass {</span></span>
<span class="line"><span>  constructor() {</span></span>
<span class="line"><span>    // 构造函数的定义</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>\`\`\`</span></span></code></pre></div></li><li><p>属性和方法： 类可以定义实例属性和方法，也可以定义静态属性和方法。</p><ul><li><p>实例属性和方法：通过在构造函数内部使用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>this</span></span></code></pre></div><p>关键字来定义。实例属性在创建实例时会被赋予不同的值。实例方法是指在类的原型上定义的方法，可以被所有实例共享。例如：</p><p>javascript</p><p>复制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class MyClass {</span></span>
<span class="line"><span>  constructor() {</span></span>
<span class="line"><span>    this.property = value; // 实例属性</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  method() {</span></span>
<span class="line"><span>    // 实例方法</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div></li><li><p>静态属性和方法：通过使用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>static</span></span></code></pre></div><p>关键字定义。静态属性和方法属于类本身，而不是类的实例。可以通过类名直接访问静态属性和方法，而无需创建类的实例。例如：</p><p>javascript</p><p>复制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class MyClass {</span></span>
<span class="line"><span>  static staticProperty = value; // 静态属性</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  static staticMethod() {</span></span>
<span class="line"><span>    // 静态方法</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div></li></ul></li><li><p>继承： 类可以通过<code>extends</code>关键字实现继承。子类可以继承父类的属性和方法，并可以覆盖或扩展它们。子类的构造函数必须调用<code>super()</code>方法来调用父类的构造函数。例如：</p><p>javascript</p><p>复制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ChildClass extends ParentClass {</span></span>
<span class="line"><span>  constructor() {</span></span>
<span class="line"><span>    super(); // 调用父类的构造函数</span></span>
<span class="line"><span>    // 子类的构造函数定义</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>\`\`\`</span></span></code></pre></div></li></ol><p>这些是ES6中类的基本原理。类提供了一种更面向对象的编程方式，使得代码更易读、易维护，并且提供了更多的语法糖来简化对象创建和继承的过程。</p><p>和 Java 类的区别</p><p>JavaScript中的类是基于原型继承的，更具灵活性和动态性，适合进行轻量级的面向对象编程。而Java中的类是基于类继承的，更加严格和静态，适合构建复杂的大型应用程序。</p><h2 id="说说-web-socket开发" tabindex="-1">说说 web socket开发 <a class="header-anchor" href="#说说-web-socket开发" aria-label="Permalink to &quot;说说 web socket开发&quot;">​</a></h2><p>WebSocket是一种在Web应用程序中实现双向通信的协议，它提供了一种持久化的连接，允许服务器主动向客户端推送数据，而不需要客户端发起请求。使用WebSocket，可以实现实时的、基于事件的双向通信，适用于许多应用场景，如实时聊天、在线游戏、实时数据更新等。</p><p>以下是WebSocket开发的一般流程和关键步骤：</p><ol><li><p>建立连接： 客户端通过JavaScript中提供的WebSocket API创建一个WebSocket对象，并指定连接的URL。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://example.com/socket&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>事件处理： WebSocket对象提供了一些事件，可以通过添加事件处理程序来处理这些事件。常见的事件包括：</p><ul><li><code>open</code>：当连接成功建立时触发。</li><li><code>message</code>：当接收到服务器发送的消息时触发。</li><li><code>error</code>：当出现连接错误时触发。</li><li><code>close</code>：当连接关闭时触发。</li></ul><p>通过监听这些事件，可以实现相应的逻辑处理。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;open&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 连接成功处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理接收到的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;error&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;close&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理连接关闭</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>发送和接收数据： 客户端可以使用WebSocket对象的<code>send</code>方法向服务器发送数据。服务器收到数据后，可以通过WebSocket对象的<code>onmessage</code>事件进行处理。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, server!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理接收到的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>服务器端实现： 在服务器端，需要编写相应的WebSocket服务器代码来处理客户端的连接和通信。不同的编程语言和框架提供了不同的WebSocket库和工具，可以根据实际需求选择适合的方案。一般来说，WebSocket服务器需要监听客户端的连接请求，并根据协议进行握手，然后可以通过发送和接收消息来与客户端进行通信。</p></li></ol><p>需要注意的是，WebSocket需要服务器端和客户端的支持。大多数现代浏览器都支持WebSocket协议，同时也有许多服务器端的实现可供选择。</p><p>WebSocket提供了一种强大的机制来实现实时的双向通信，并且相对于其他技术（如长轮询或服务器推送事件）来说，它提供了更高效、更实时的通信方式。通过WebSocket，开发者可以构建出更具交互性和实时性的Web应用程序。</p><h2 id="webpack中哪里用到了websocket" tabindex="-1">webpack中哪里用到了websocket <a class="header-anchor" href="#webpack中哪里用到了websocket" aria-label="Permalink to &quot;webpack中哪里用到了websocket&quot;">​</a></h2><p>在Webpack中，WebSocket（或者类似的实时通信协议）通常用于以下几个方面：</p><ol><li><p>Webpack Dev Server： Webpack Dev Server是一个用于开发环境的轻量级HTTP服务器，提供了诸如热重载（Hot Module Replacement）和自动刷新等功能。当使用Webpack Dev Server时，它会在Webpack构建过程中使用WebSocket来与浏览器建立持久连接，以便在构建完成后实时更新修改的模块，从而使开发者能够快速看到代码变化的效果。</p></li><li><p>模块热替换（Hot Module Replacement）： 模块热替换是Webpack的一个功能，它允许在应用程序运行时替换、添加或删除模块，而无需完全刷新页面。当某个模块发生变化时，Webpack会使用WebSocket与浏览器通信，将变更的模块代码传递给浏览器进行更新，从而实现实时的模块热替换。</p></li><li><p>Webpack 插件： 有些Webpack插件可能会使用WebSocket来实现与开发服务器或其他工具之间的实时通信。例如，一些自动刷新浏览器插件可能会使用WebSocket来通知浏览器刷新页面，以显示最新的构建结果。</p></li></ol><p>需要注意的是，上述使用WebSocket的功能主要是在开发环境中使用，用于提高开发效率、加快开发调试过程。在生产环境中，通常不会使用WebSocket来实现实时更新，而是通过构建工具将代码打包为静态文件，并将其提供给服务器进行部署。</p><h2 id="web-socket-的应用场景" tabindex="-1">web socket 的应用场景 <a class="header-anchor" href="#web-socket-的应用场景" aria-label="Permalink to &quot;web socket 的应用场景&quot;">​</a></h2><p>WebSocket的应用场景包括但不限于以下几个方面：</p><ol><li><p>实时聊天应用： WebSocket提供了双向通信的能力，非常适合用于实现实时聊天应用程序。通过WebSocket，可以实现用户之间的实时消息传递，包括文字、图像、音频等。</p></li><li><p>实时数据更新： WebSocket可以用于实时更新数据，特别适用于需要及时展示数据变化的应用场景。例如，股票市场行情、实时监控系统、实时协作应用等。服务器可以将数据实时推送给客户端，客户端接收到数据后立即更新展示。</p></li><li><p>多人在线游戏： WebSocket可以用于构建多人在线游戏，实现玩家之间的实时通信和交互。通过WebSocket，服务器可以快速将游戏状态、玩家操作等信息传递给所有玩家，实现实时同步。</p></li><li><p>实时协作应用： 如果需要多个用户协作编辑同一个文档或项目，WebSocket可以提供实时协作的功能。用户之间的编辑操作可以实时同步，确保团队成员之间的实时沟通和协作。</p></li><li><p>实时通知和提醒： WebSocket可以用于向用户发送实时通知和提醒。例如，社交媒体应用可以使用WebSocket向用户推送新消息、新关注者或其他相关信息。</p></li><li><p>在线客服和客户支持： WebSocket可以用于实现在线客服系统，使客服人员能够与客户实时交流和解决问题。客户可以实时向客服发送消息，客服人员可以即时回复。</p></li></ol><p>总的来说，WebSocket适用于需要实时双向通信的应用场景，其中需要将服务器端的数据实时推送给客户端，或者需要客户端与服务器之间进行实时交互和通信的情况。WebSocket提供了更高效、更实时的通信方式，相对于传统的轮询或长连接等技术，具有更低的延迟和更高的效率。</p><h2 id="说说canvas绘制" tabindex="-1">说说canvas绘制 <a class="header-anchor" href="#说说canvas绘制" aria-label="Permalink to &quot;说说canvas绘制&quot;">​</a></h2><p>Canvas是HTML5提供的一种图形绘制API，它允许通过JavaScript来绘制图形、动画和交互式内容。使用Canvas，你可以在网页中创建各种图形，包括线条、矩形、圆形、文本等，并且可以对这些图形进行样式设置和动态操作。</p><p>以下是Canvas绘制的一般流程和关键步骤：</p><ol><li><p>获取Canvas元素： 首先，需要在HTML文档中创建一个Canvas元素，并通过JavaScript获取到该元素的引用。例如：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myCanvas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`\`javascript</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const canvas = document.getElementById(&#39;myCanvas&#39;);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`</span></span></code></pre></div></li><li><p>获取绘图上下文： 通过Canvas元素的<code>getContext</code>方法获取绘图上下文。绘图上下文是进行图形绘制的核心对象，通过它可以进行各种绘制操作。常用的上下文类型为<code>2d</code>，即2D绘图上下文。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>绘制基本图形： 使用绘图上下文的各种方法来绘制基本图形，如线条、矩形、圆形等。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绘制线条</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beginPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">moveTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lineTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stroke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绘制矩形</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.fillStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;red&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">150</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绘制圆形</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beginPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stroke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>设置样式属性： 通过设置绘图上下文的样式属性，可以改变绘制图形的颜色、线条样式、字体等。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置线条颜色</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.strokeStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;blue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置填充颜色</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.fillStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;yellow&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置线条宽度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.lineWidth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置字体样式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.font </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;24px Arial&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>绘制文本： 使用绘图上下文的<code>fillText</code>或<code>strokeText</code>方法来绘制文本。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.font </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;24px Arial&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Canvas!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li><li><p>绘制图像： 使用绘图上下文的<code>drawImage</code>方法可以将图像绘制到Canvas上。可以使用<code>Image</code>对象或<code>CanvasImageSource</code>对象作为绘制的源图像。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">image.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;image.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">image.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drawImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(image, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`</span></span></code></pre></div></li></ol><p>在绘制过程中，可以根据需要进行动画更新、交互操作和事件处理等。Canvas提供了丰富的API和功能，使开发者能够实现各种精彩的图形和动画效果。</p><p>需要注意的是，Canvas是一种基于像素的绘图方式，绘制的图形是以像素为单位的。因此，在绘制之前需要考虑Canvas的大小和分辨率，以确保图形在不同设备上显示一致。此外，Canvas也支持一些高级功能，如路径绘制、渐变、阴影等，可以进一步扩展绘制的能力和效果。</p><h2 id="css-em-rem-px-vh-vw简单说下" tabindex="-1">Css :em rem px vh vw简单说下 <a class="header-anchor" href="#css-em-rem-px-vh-vw简单说下" aria-label="Permalink to &quot;Css :em rem px vh vw简单说下&quot;">​</a></h2><p>在CSS中，常见的单位包括<code>em</code>、<code>rem</code>、<code>px</code>、<code>vh</code>和<code>vw</code>。它们用于指定元素的尺寸和位置。</p><ul><li><p><code>em</code>：相对于父元素的字体大小。例如，如果一个元素的字体大小为16像素，设置其宽度为2em，则宽度将为32像素（2倍于字体大小）。</p></li><li><p><code>rem</code>：相对于根元素（即<code>&lt;html&gt;</code>元素）的字体大小。如果根元素的字体大小为16像素，设置一个元素的高度为1.5rem，则高度将为24像素（1.5倍于根元素的字体大小）。</p></li><li><p><code>px</code>：像素单位，固定的绝对尺寸。它指定元素的大小和位置为具体的像素值。例如，<code>width: 200px;</code>表示元素的宽度为200像素。</p></li><li><p><code>vh</code>：视窗高度的百分比。1vh等于视窗高度的1%。例如，如果视窗高度为800像素，设置一个元素的高度为50vh，则高度将为400像素（50%的视窗高度）。</p></li><li><p><code>vw</code>：视窗宽度的百分比。1vw等于视窗宽度的1%。例如，如果视窗宽度为1200像素，设置一个元素的宽度为25vw，则宽度将为300像素（25%的视窗宽度）。</p></li></ul><p>这些单位在响应式设计和移动优化中非常有用。使用相对单位（如<code>em</code>、<code>rem</code>、<code>vh</code>和<code>vw</code>）可以使元素的尺寸和间距根据父元素或视窗的大小自适应调整，从而在不同的设备和屏幕尺寸上实现一致的布局和用户体验。而使用像素单位（<code>px</code>）则表示固定的绝对尺寸，适用于需要精确控制元素大小和位置的场景。</p><p>需要根据具体的设计需求和响应式要求选择合适的单位。使用相对单位可以提高页面的灵活性和可维护性，而使用像素单位则可以精确控制元素的外观和布局。</p>`,35),l=[e];function t(h,k,c,d,E,r){return a(),i("div",null,l)}const y=s(p,[["render",t]]);export{g as __pageData,y as default};
