import{_ as e,c as a,o as i,a4 as l}from"./chunks/framework.C5rzuSi5.js";const f=JSON.parse('{"title":"面壁智能","description":"","frontmatter":{},"headers":[],"relativePath":"fe/interview/公司面试/面壁智能.md","filePath":"fe/interview/公司面试/面壁智能.md","lastUpdated":1699668135000}'),o={name:"fe/interview/公司面试/面壁智能.md"},r=l('<h1 id="面壁智能" tabindex="-1">面壁智能 <a class="header-anchor" href="#面壁智能" aria-label="Permalink to &quot;面壁智能&quot;">​</a></h1><p>大模型相关业务，有B+C端，有小程序</p><p>vue</p><ul><li>说说 diff 算法</li><li>说说虚拟 dom</li><li>vue 的生命周期</li><li>slow 插槽</li><li>对 v-model 的理解</li><li>vue 的事件处理底层是什么样的</li><li>说说对 <code>$nextTick</code> 的理解</li><li>对于页面加载优化做过哪些优化</li></ul><p>项目</p><ul><li>说说项目都有哪些公共设施</li></ul><p>http</p><ul><li>说说浏览器缓存</li></ul><p>笔试题</p><ul><li>字符串中快速找出重复字符，输出字符以及字符的个数</li><li>实现一个model弹框，有遮罩（背景是毛玻璃效果），内容头中尾，头部可拖拽</li></ul><p>浏览器的进程和线程</p><h2 id="如何实现浏览器-同域名不同tab的通信" tabindex="-1">如何实现浏览器，同域名不同tab的通信 <a class="header-anchor" href="#如何实现浏览器-同域名不同tab的通信" aria-label="Permalink to &quot;如何实现浏览器，同域名不同tab的通信&quot;">​</a></h2><p>在同一个域名下的不同标签页之间进行通信可以使用以下几种方法：</p><ol><li><p>使用LocalStorage或SessionStorage：LocalStorage和SessionStorage是HTML5提供的Web存储机制，可以在浏览器标签页之间共享数据。你可以在一个标签页中将数据存储到LocalStorage或SessionStorage中，然后在其他标签页中读取该数据。当数据发生变化时，你可以通过监听Storage事件来实时更新数据。</p></li><li><p>使用BroadcastChannel API：BroadcastChannel API是HTML5中的新API，它提供了一种跨标签页通信的机制。你可以在一个标签页中创建一个BroadcastChannel实例，并使用<code>postMessage</code>方法向其他标签页发送消息。其他标签页可以通过监听<code>message</code>事件来接收并处理这些消息。</p></li><li><p>使用SharedWorker：SharedWorker是一种可以在多个浏览器标签页之间共享的Web Worker。你可以在一个标签页中创建一个SharedWorker，并通过它进行通信。其他标签页可以连接到同一个SharedWorker，并通过它发送和接收消息。</p></li><li><p>使用Cookies：Cookies是一种在浏览器和服务器之间传递数据的机制。你可以在一个标签页中设置一个具有相同域名的Cookie，然后在其他标签页中读取该Cookie。当Cookie的值发生变化时，你可以通过轮询或监听Cookie变化事件来实时获取更新的数据。</p></li></ol><p>这些方法都可以实现浏览器同域名下不同标签页之间的通信。选择适合你的需求和场景的方法，并根据具体情况实现相应的逻辑。需要注意的是，这些方法都是基于浏览器提供的特性，所以在使用时请确保你的目标浏览器支持相应的API。</p><h2 id="微前端为什么iframe加载比qiankun慢" tabindex="-1">微前端为什么iframe加载比qiankun慢 <a class="header-anchor" href="#微前端为什么iframe加载比qiankun慢" aria-label="Permalink to &quot;微前端为什么iframe加载比qiankun慢&quot;">​</a></h2><p>在微前端中，使用iframe加载子应用相比于qiankun框架可能会导致加载速度较慢的情况，这主要是由于以下几个原因：</p><ol><li><p>页面加载开销：使用iframe加载子应用需要创建新的HTML文档，并加载子应用的HTML、CSS和JavaScript资源。相比之下，qiankun框架使用动态脚本加载子应用的资源，避免了创建新的HTML文档和重新加载资源的开销，从而提高了加载速度。</p></li><li><p>额外的网络请求：使用iframe加载子应用可能需要额外的网络请求来获取子应用的资源。每个iframe都需要发起一次HTTP请求来获取子应用的HTML、CSS和JavaScript文件。而qiankun框架使用动态脚本加载子应用的资源，可以通过预加载或并行加载的方式减少网络请求的数量，提高加载效率。</p></li><li><p>多个页面上下文切换：使用iframe加载子应用会导致子应用运行在独立的上下文中，每次切换到子应用都需要进行上下文切换，包括创建新的JavaScript执行环境、解析和执行子应用的代码等。而qiankun框架在同一个页面中运行子应用，避免了上下文切换的开销，提高了整体性能。</p></li><li><p>通信成本：在iframe中的子应用与主应用之间的通信需要通过跨文档消息（postMessage）或其他手段进行，这会增加通信的成本和复杂性。而qiankun框架通过JavaScript沙箱和事件机制来实现主子应用之间的通信，更加高效和方便。</p></li></ol><p>综上所述，使用iframe加载子应用相比于qiankun框架可能会导致加载速度较慢，主要是由于页面加载开销、额外的网络请求、多个页面上下文切换以及通信成本等因素的影响。因此，在选择微前端方案时，综合考虑性能、开发效率和用户体验等因素，选择合适的方案进行开发和部署。</p><p>项目里的难点，复杂点</p>',20),t=[r];function n(p,s,c,d,u,_){return i(),a("div",null,t)}const k=e(o,[["render",n]]);export{f as __pageData,k as default};
