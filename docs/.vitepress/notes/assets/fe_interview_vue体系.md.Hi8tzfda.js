import{_ as l,c as a,o as e,a4 as s}from"./chunks/framework.C5rzuSi5.js";const i="/assets/image-20231013075153869.C2ghevQc.png",t="/assets/image-20231013101122828.BbAQUPSC.png",h="/assets/image-20231013101152098.MpBPuA2N.png",n="/assets/image-20231013101431227.BPRZJUaR.png",r="/assets/image-20231013101501380.BQd-jTnT.png",o="/assets/image-20231013101545880.C7HWY8UQ.png",p="/assets/image-20231013101640605.CtQiXfom.png",u="/assets/image-20231013101854652.BktfamWq.png",d="/assets/image-20231013101959000.DAgMedDX.png",k="/assets/image-20231013104301985.DI7uSVjD.png",c="/assets/image-20231013205915026.BQ4Ko8hm.png",m="/assets/image-20231013210718754.CLE-b-RQ.png",E="/assets/image-20231013211600883.J6E4Vx63.png",C=JSON.parse('{"title":"Vue面试","description":"","frontmatter":{},"headers":[],"relativePath":"fe/interview/vue体系.md","filePath":"fe/interview/vue体系.md","lastUpdated":1698219558000}'),f={name:"fe/interview/vue体系.md"},g=s('<h1 id="vue面试" tabindex="-1">Vue面试 <a class="header-anchor" href="#vue面试" aria-label="Permalink to &quot;Vue面试&quot;">​</a></h1><h2 id="vue-基本使用-常用必须会" tabindex="-1">Vue 基本使用（常用必须会） <a class="header-anchor" href="#vue-基本使用-常用必须会" aria-label="Permalink to &quot;Vue 基本使用（常用必须会）&quot;">​</a></h2><ul><li><p>基本使用</p><ul><li><p>模板（插值，指令）</p></li><li><p>computed 和 watch</p></li><li><p>class 和 style</p></li><li><p>条件</p></li><li><p>循环</p></li><li><p>事件</p></li><li><p>表单</p></li></ul></li><li><p>组件</p><ul><li>生命周期</li><li>props（类型和默认值）</li><li>v-on和$emit</li><li>自定义事件</li></ul></li></ul><h3 id="基本使用" tabindex="-1">基本使用 <a class="header-anchor" href="#基本使用" aria-label="Permalink to &quot;基本使用&quot;">​</a></h3><h4 id="computed-和-watch" tabindex="-1">computed 和 watch <a class="header-anchor" href="#computed-和-watch" aria-label="Permalink to &quot;computed 和 watch&quot;">​</a></h4><ul><li>computed 有缓存，data不变则不会重新计算</li><li>watch如何深度监听</li><li>watch 监听引用类型，拿不到 oldVal</li></ul><h4 id="class-和-style" tabindex="-1">class 和 style <a class="header-anchor" href="#class-和-style" aria-label="Permalink to &quot;class 和 style&quot;">​</a></h4><ul><li>使用动态属性</li><li>使用驼峰式写法</li></ul><h4 id="条件渲染" tabindex="-1">条件渲染 <a class="header-anchor" href="#条件渲染" aria-label="Permalink to &quot;条件渲染&quot;">​</a></h4><ul><li>v-if v-else的用法，可使用变量，也可以使用 === 表达式</li><li>v-if 和 v-show 的区别</li><li>v-if 和 v-show 的使用场景</li></ul><h4 id="循环-列表-渲染" tabindex="-1">循环（列表）渲染 <a class="header-anchor" href="#循环-列表-渲染" aria-label="Permalink to &quot;循环（列表）渲染&quot;">​</a></h4><ul><li>如何遍历对象？也可以使用 v-for</li><li>key重要性。key 不能乱写（如 random 或 index）</li><li>v-for 和 v-if 不能一起使用</li></ul><h4 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h4><ul><li>event 参数，自定义参数</li><li>事件修饰符，按键修饰符</li><li>【观察】事件被绑定到哪里？</li></ul><h4 id="事件修饰符" tabindex="-1">事件修饰符 <a class="header-anchor" href="#事件修饰符" aria-label="Permalink to &quot;事件修饰符&quot;">​</a></h4><h4 id="按键修饰符" tabindex="-1">按键修饰符 <a class="header-anchor" href="#按键修饰符" aria-label="Permalink to &quot;按键修饰符&quot;">​</a></h4><h4 id="表单" tabindex="-1">表单 <a class="header-anchor" href="#表单" aria-label="Permalink to &quot;表单&quot;">​</a></h4><ul><li>v-model</li><li>常见表单项 textarea checkbox radio select</li><li>修饰符 lazy number trim</li></ul><h3 id="vue-组件使用" tabindex="-1">Vue 组件使用 <a class="header-anchor" href="#vue-组件使用" aria-label="Permalink to &quot;Vue 组件使用&quot;">​</a></h3><ul><li>props 和 $emit</li><li>组件间通讯 - 自定义事件，beforeDestory销毁自定义事件</li><li>组件生命周期</li></ul><h4 id="props-和-emit" tabindex="-1">props 和 $emit <a class="header-anchor" href="#props-和-emit" aria-label="Permalink to &quot;props 和 $emit&quot;">​</a></h4><h4 id="组件间通讯" tabindex="-1">组件间通讯 <a class="header-anchor" href="#组件间通讯" aria-label="Permalink to &quot;组件间通讯&quot;">​</a></h4><h4 id="组件生命周期" tabindex="-1">组件生命周期 <a class="header-anchor" href="#组件生命周期" aria-label="Permalink to &quot;组件生命周期&quot;">​</a></h4><p><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram" target="_blank" rel="noreferrer">https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram</a></p><p>单个组件</p><ul><li>挂载阶段</li><li>更新阶段</li><li>销毁阶段</li></ul><p>父子组件</p><h2 id="vue-高级使用-不常用-但体现深度" tabindex="-1">Vue 高级使用（不常用，但体现深度） <a class="header-anchor" href="#vue-高级使用-不常用-但体现深度" aria-label="Permalink to &quot;Vue 高级使用（不常用，但体现深度）&quot;">​</a></h2><ul><li>自定义 v-model</li><li>$nextTick</li><li>refs</li><li>slot</li><li>动态、异步组件</li><li>keep-alive</li><li>mixin</li></ul><h4 id="自定义-v-model" tabindex="-1">自定义 v-model <a class="header-anchor" href="#自定义-v-model" aria-label="Permalink to &quot;自定义 v-model&quot;">​</a></h4><h4 id="nexttick" tabindex="-1">$nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;$nextTick&quot;">​</a></h4><ul><li>Vue 是异步渲染</li><li>data 改变之后，DOM 不会立刻渲染</li><li>$nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点</li></ul><h4 id="slot" tabindex="-1">slot <a class="header-anchor" href="#slot" aria-label="Permalink to &quot;slot&quot;">​</a></h4><ul><li>基本使用</li><li>作用域插槽</li><li>具名插槽</li></ul><h4 id="动态组件" tabindex="-1">动态组件 <a class="header-anchor" href="#动态组件" aria-label="Permalink to &quot;动态组件&quot;">​</a></h4><ul><li>:is=&quot;component-name&quot;用法</li><li>需要根据数据，动态渲染的场景。即组件类型不确定</li></ul><h4 id="异步组件-常用" tabindex="-1">异步组件（常用） <a class="header-anchor" href="#异步组件-常用" aria-label="Permalink to &quot;异步组件（常用）&quot;">​</a></h4><p>比较大的组件</p><ul><li>import() 函数</li><li>按需加载，异步加载大组件</li></ul><h4 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h4><ul><li>缓存组件</li><li>频繁切换，不需要重复渲染</li><li>Vue 常见性能优化</li></ul><h4 id="mixin" tabindex="-1">mixin <a class="header-anchor" href="#mixin" aria-label="Permalink to &quot;mixin&quot;">​</a></h4><ul><li>多个组件有相同的逻辑，抽离出来</li><li>mixin的问题 <ul><li>变量来源不明确，不利于阅读</li><li>多个 mixin 可能会造成命名冲突</li><li>mixin 和组件可能出现多对多的关系，复杂度较高</li></ul></li></ul><h2 id="vuex" tabindex="-1">Vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;Vuex&quot;">​</a></h2><ul><li>面试考点不多</li><li>基本概念、基本使用和 API 必须掌握</li><li>可能会考察 state 的数据结构设计</li></ul><img src="http://cdn.wangtongmeng.com/20231011145224-9cc0bd.png" style="zoom:33%;"><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><ul><li>state</li><li>getters</li><li>action</li><li>mutation</li></ul><h3 id="用于-vue-组件" tabindex="-1">用于 Vue 组件 <a class="header-anchor" href="#用于-vue-组件" aria-label="Permalink to &quot;用于 Vue 组件&quot;">​</a></h3><ul><li>dispatch</li><li>commit</li><li>mapState</li><li>mapGetters</li><li>mapActions</li><li>mapMutaions</li></ul><h2 id="vue-router-使用" tabindex="-1">Vue-router 使用 <a class="header-anchor" href="#vue-router-使用" aria-label="Permalink to &quot;Vue-router 使用&quot;">​</a></h2><ul><li>面试考点不多（前提是熟悉vue）</li><li>路由模式（hash、H5 history）</li><li>路由配置（动态路由、路由懒加载）</li></ul><h3 id="路由模式" tabindex="-1">路由模式 <a class="header-anchor" href="#路由模式" aria-label="Permalink to &quot;路由模式&quot;">​</a></h3><ul><li>hash模式（默认），如 <code>http://abc.com/#/user/10</code></li><li>h5 history 模式，如 <code>http://abc.com/user/20</code>，需要服务端找不到path也返回首页，有前端来控制显示路由页面（正常路由页面和404页面）</li></ul><h4 id="路由配置" tabindex="-1">路由配置 <a class="header-anchor" href="#路由配置" aria-label="Permalink to &quot;路由配置&quot;">​</a></h4><h2 id="vue2原理" tabindex="-1">Vue2原理 <a class="header-anchor" href="#vue2原理" aria-label="Permalink to &quot;Vue2原理&quot;">​</a></h2><p>使用相关的原理，例如vdom、模板渲染</p><p>整体流程是否全面？热门技术是否有深度？</p><ul><li>组件化</li><li>响应式</li><li>vdom 和 diff</li><li>模板编译</li><li>渲染过程</li><li>前端路由</li></ul><h3 id="组件化" tabindex="-1">组件化 <a class="header-anchor" href="#组件化" aria-label="Permalink to &quot;组件化&quot;">​</a></h3><ul><li>传统组件，只是静态渲染，更新还要依赖操作 DOM</li><li>数据驱动视图 - Vue MVVM，React setState</li></ul><h3 id="响应式" tabindex="-1">响应式 <a class="header-anchor" href="#响应式" aria-label="Permalink to &quot;响应式&quot;">​</a></h3><ul><li>核心API - Object.defineProperty</li><li>如何实现响应式 <ul><li>监听对象、数组</li><li>复杂对象，深度监听</li></ul></li><li>缺点</li><li>proxy <ul><li>兼容性不好，且无法 polyfill（不需要考虑兼容性的用vue3，否则还得用vue2）</li></ul></li></ul><p>Object.defineProperty基本用法</p><p>Object.defineProperty实现响应式</p><ul><li>监听对象，监听数组</li><li>复杂对象，深度监听</li><li>缺点 <ul><li>深度监听，需要递归到底，一次性计算量大</li><li>无法监听新增属性/删除属性(Vue.set Vue.delete)</li></ul></li></ul><h3 id="vdom-和-diff" tabindex="-1">vdom 和 diff <a class="header-anchor" href="#vdom-和-diff" aria-label="Permalink to &quot;vdom 和 diff&quot;">​</a></h3><ul><li><p>DOM 操作非常耗费性能</p></li><li><p>Vue 和 React 都是数据驱动视图，如何有效控制 DOM 操作</p></li><li><p>细节不重要，updateChildren 的过程也不重要，不要深究</p></li><li><p>vdom 核心概念很重要：h、vnode、patch、diff、key等</p></li><li><p>vdom 存在的价值更加重要：数据驱动视图，控制 DOM 操作</p></li></ul><p>Diff</p><ul><li>PatchVnode</li><li>AddVnodes removeVnodes</li><li>UpdateChildren（key的重要性)</li><li>vue 参考 snabbdom 实现的 vdom 和diff</li></ul><p>vdom</p><ul><li>用 JS 模拟 DOM 结构（vnode）</li><li>新旧vnode对比，得出最小的更新范围，最后更新 DOM</li><li>数据驱动视图的模式下，有效控制 DOM 操作</li></ul><p>diff 算法</p><ul><li>Diff 算法是 vdom 中最核心、最关键的部分</li><li>diff 算法能在日常使用 vue react 中体现出来(如 key)</li></ul><p>树 diff 的时间复杂度 O(n^3)</p><ul><li>第一，遍历tree1；第二，遍历 tree2</li><li>第三，排序</li><li>1000个节点，要计算 1 亿次，算法不可用</li></ul><p>优化时间复杂度到 O(n)</p><ul><li>只比较同一层级，不跨级比较</li><li>Tag 不相同，则直接删掉重建，不再深度比较</li><li>Tag 和 key , 两者都相同，则认为是相同节点，不再深度比较</li></ul><h3 id="模板编译" tabindex="-1">模板编译 <a class="header-anchor" href="#模板编译" aria-label="Permalink to &quot;模板编译&quot;">​</a></h3><ul><li>模板是 vue 开发中最常用的部分，即与使用相关联的原理</li><li>它不是html，有指令、插值、JS 表达式，到底是什么？</li><li>面试不会直接问，但会通过”组件渲染和更新过程“考察</li></ul><p>模板编译</p><ul><li>前置知识：JS 的 with 语法</li><li>vue template compiler 将模板编译为 render 函数</li><li>执行 render 函数生成 vnode</li></ul><p>with语法</p><ul><li>改变 {} 内自由变量的查找规则，当做 obj 属性来查找</li><li>如果找不到匹配的 obj 属性，就会报错</li><li>With 要慎用，它打破了作用域规则，易读性变差</li></ul><p>编译模板</p><ul><li>模板不是 html，有指令、插值、JS 表达式，能实现判断、循环</li><li>html 是标签语言，只有 JS 才能实现判断、循环(图灵完备)</li><li>因此，模板一定是转换为某种 JS 代码，即编译模板</li></ul><p>总结</p><ul><li>模板编译为 render 函数，执行 render 函数返回 vnode</li><li>基于 vnode 再执行 patch 和 diff</li><li>使用 webpack vue-loader，会在开发环境下编译模板(重要)</li></ul><p>vue 组件中使用 render 代替 template</p><ul><li>模板编译就是 render 函数</li><li>在一些复杂情况下，不能用 template，可以考虑用 render</li></ul><p>总结</p><ul><li>with 语法</li><li>模板到 render 函数，再到 vnode，再到渲染和更新</li><li>vue 组件可以用 render 代替 template</li></ul><h3 id="组件渲染-更新过程" tabindex="-1">组件渲染/更新过程 <a class="header-anchor" href="#组件渲染-更新过程" aria-label="Permalink to &quot;组件渲染/更新过程&quot;">​</a></h3><ul><li>一个组件渲染到页面，修改 data 触发更新(更新视图)</li><li>初次渲染过程 <ul><li>解析模板为 render 函数（或在开发环境下已完成，vue-loader）</li><li>触发响应式，监听 data 属性 getter setter</li><li>执行 render 函数(会触发getter)，生成 vnode，patch(elem, vnode)</li></ul></li><li>更新过程 <ul><li>修改 data，触发 setter（此前在 getter 中已被监听）</li><li>重新执行 render 函数，生成 newVnode</li><li>patch(vnode, newVnode)</li></ul></li><li>异步渲染</li><li><ul><li>$nextTick</li><li>汇总 data 的修改，一次性更新视图</li><li>减少 DOM 操作次数，提高性能</li></ul></li></ul><img src="http://cdn.wangtongmeng.com/20231012163717.png" style="zoom:33%;"><h3 id="前端路由" tabindex="-1">前端路由 <a class="header-anchor" href="#前端路由" aria-label="Permalink to &quot;前端路由&quot;">​</a></h3><p>路由模式 hash、history</p><p>hash 的特点</p><ul><li>hash 变化会触发网页跳转，即浏览器的前进、后退</li><li>hash 变化不会刷新页面，spa 必须得特点</li><li>hash 永远不会提交到 server 端</li></ul><p>H5 history</p><ul><li>用 url 规范的路由，但跳转时不刷新页面</li><li>history.pushState</li><li>window.onpopstate</li></ul><p>总结</p><ul><li>hash - window.onhashchange</li><li>H5 history - history.pushState 和 window.onpopstate</li><li>H5 history 需要后端支持</li></ul><p>两者选择</p><ul><li>to B 的系统推荐用 hash，简单易用，对 url 规范不敏感</li><li>to C 的系统，可以考虑选择 H5 history，但需要服务端支持</li></ul><h2 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h2><p>功能</p><ul><li>createApp</li><li>emits 属性</li><li>多事件处理</li><li>Fragment</li><li>移除 .sync 改为 v-model 参数</li><li>异步组件的引用方式</li><li>移除 filter</li><li>Teleport</li><li>Suspense</li><li>Composition Api <ul><li>reactive</li><li>ref toRef toRefs</li><li>readonly</li><li>computed</li><li>watch watchEffect</li><li>钩子函数生命周期</li></ul></li></ul><p>原理</p><ul><li>Proxy 实现响应式</li><li>编译优化 <ul><li>PatchFlag 静态标记</li><li>HoistStatic 静态提升</li><li>CacheHandler 缓存事件</li><li>SSR 优化</li><li>Tree-shaking 优化</li></ul></li></ul><p>Vite</p><ul><li>ES6 Moudle</li></ul><h3 id="compostion-api-对比-options-api" tabindex="-1">Compostion API 对比 Options API <a class="header-anchor" href="#compostion-api-对比-options-api" aria-label="Permalink to &quot;Compostion API 对比 Options API&quot;">​</a></h3><h3 id="如何理解-ref-toref-和-torefs" tabindex="-1">如何理解 ref toRef 和 toRefs <a class="header-anchor" href="#如何理解-ref-toref-和-torefs" aria-label="Permalink to &quot;如何理解 ref toRef 和 toRefs&quot;">​</a></h3><p>Ref</p><ul><li>是什么 <ul><li>生成值类型的响应式数据</li><li>可用于模板和 reactive(会自动取值，不需要.value)</li><li>通过 .value修改值</li></ul></li><li>最佳使用方式</li><li>进阶，深入理解</li></ul><p>toRef</p><ul><li>针对一个响应式对象(reactive封装)的prop</li><li>创建一个ref，具有响应式</li><li>两者保持引用关系</li></ul><p>toRefs</p><ul><li>将响应式对象(reactive封装)转换为普通对象</li><li>对象的每个prop 都是对应的ref</li><li>两者保持引用关系</li></ul><p>合成函数返回响应式对象（解构）</p><p><img src="'+i+`" alt="image-20231013075153869"></p><p>最佳使用</p><ul><li>用 reactive 做对象的响应式，用 ref 做值类型响应式</li><li>setup 中返回 toRefs(state)，或者toRef(state, &#39;xxx&#39;)</li><li>ref 的变量命名都用 xxxRef</li><li>合成函数返回响应式对象时，使用 toRefs，方便解构</li></ul><p>进阶，深入理解</p><ul><li>为何需要 ref ？ <ul><li>返回值类型，会丢失响应式</li><li>在 setup、computed、合成函数，都有可能返回值类型</li></ul></li><li>为何需要 .value ？ <ul><li>ref 是一个对象(不丢失响应式)，value 存储值</li><li>通过 .value 属性的 get 和 set 实现响应式</li><li>用于模板、reactive 时，不需要 .value，其他情况都需要</li></ul></li><li>为何需要 toRef toRefs ？ <ul><li>初衷：不丢失响应式的情况下，把对象数据 分解(解构)/扩散</li><li>前提：针对的是响应式对象(reactive 封装的) 非普通对象</li><li>注意：不创造响应式，而是延续响应式</li></ul></li></ul><p>总结</p><ul><li>ref toRef toRefs 是什么</li><li>最佳使用方式</li><li>原理</li></ul><h3 id="vue3-和-jsx" tabindex="-1">Vue3 和 JSX <a class="header-anchor" href="#vue3-和-jsx" aria-label="Permalink to &quot;Vue3 和 JSX&quot;">​</a></h3><ul><li>Vue3 中 JSX 的基本使用 <ul><li>基本使用</li><li>使用 .jsx 格式文件和 defineComponent</li><li>引用自定义组件，传递属性</li></ul></li><li>JSX 和 template 的区别 <ul><li>语法有很大区别 <ul><li>JSX 本质就是 js 代码，可以使用 js 的任何能力</li><li>template 只能嵌入简单的 js 表达式，其他需要使用指令，如 v-if</li><li>JSX 已经成为 ES 规范，template 还是 Vue 自家规范</li></ul></li><li>本质是相同的 <ul><li>都会被编译成 js 代码(render函数)</li></ul></li><li>具体示例：插值，自定义组件，属性和事件，条件和循环</li></ul></li><li>JSX 和 slot(体会 JSX 的优越性) <ul><li>slot 是 Vue 发明的概念，为了完善 tempalte 的能力</li></ul></li></ul><h3 id="script-setup-vue-3-2" tabindex="-1">script setup（vue&gt;=3.2） <a class="header-anchor" href="#script-setup-vue-3-2" aria-label="Permalink to &quot;script setup（vue&gt;=3.2）&quot;">​</a></h3><ul><li>Vue3 引入了 composition API</li><li>composition API 最重要的是 setup 函数</li><li>基本使用 <ul><li>顶级变量、自定义组件，可以直接用于模板</li><li>可正常使用 ref reactive computed 等能力</li><li>和其他 <code>&lt;script&gt;</code> 同时使用</li></ul></li><li>属性和事件 <ul><li>defineProps</li><li>defineEmits</li></ul></li><li>defineExpose <ul><li>暴露数据给父组件</li></ul></li></ul><p>总结</p><ul><li>基本使用，<code>&lt;script&gt;</code>写在<code>&lt;tempalte&gt;</code>前面</li><li>定义属性 defineProps，定义事件 defineEmits</li><li>DefineExpose 暴露数据给父组件</li></ul><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><h3 id="v-show-和-v-if-的区别" tabindex="-1">v-show 和 v-if 的区别 <a class="header-anchor" href="#v-show-和-v-if-的区别" aria-label="Permalink to &quot;v-show 和 v-if 的区别&quot;">​</a></h3><ul><li>v-show 通过 css display 控制显示和隐藏</li><li>v-if 组件真正的渲染和销毁，而不是显示和隐藏</li><li>频繁切换显示状态用 v-show，否则用 v-if</li></ul><h3 id="为何-v-for-中要用-key" tabindex="-1">为何 v-for 中要用 key <a class="header-anchor" href="#为何-v-for-中要用-key" aria-label="Permalink to &quot;为何 v-for 中要用 key&quot;">​</a></h3><ul><li>必须用 key，且不能是 index 和 random</li><li>diff 算法中通过 tag 和 key 来判断，是否是 sameNode</li><li>减少渲染次数，提升渲染性能</li></ul><h3 id="描述-vue-组件生命周期-有父子组件的情况" tabindex="-1">描述 Vue 组件生命周期（有父子组件的情况） <a class="header-anchor" href="#描述-vue-组件生命周期-有父子组件的情况" aria-label="Permalink to &quot;描述  Vue 组件生命周期（有父子组件的情况）&quot;">​</a></h3><ul><li>单组件生命周期图</li><li>父子组件生命周期关系</li></ul><h3 id="vue-组件如何通讯" tabindex="-1">Vue 组件如何通讯 <a class="header-anchor" href="#vue-组件如何通讯" aria-label="Permalink to &quot;Vue 组件如何通讯&quot;">​</a></h3><ul><li>父子组件 props 和 this.$emit</li><li>自定义事件 event.$on event.$off event.$emit</li><li>vuex</li></ul><h3 id="描述组件渲染和更新的过程" tabindex="-1">描述组件渲染和更新的过程 <a class="header-anchor" href="#描述组件渲染和更新的过程" aria-label="Permalink to &quot;描述组件渲染和更新的过程&quot;">​</a></h3><h3 id="双向数据绑定-v-model-的实现原理" tabindex="-1">双向数据绑定 v-model 的实现原理 <a class="header-anchor" href="#双向数据绑定-v-model-的实现原理" aria-label="Permalink to &quot;双向数据绑定 v-model 的实现原理&quot;">​</a></h3><ul><li>input 元素的 value = this.name</li><li>绑定 input 事件 this.name = $event.target.value</li><li>data 更新触发 re-render</li></ul><h3 id="对-mvvm-的理解" tabindex="-1">对 MVVM 的理解 <a class="header-anchor" href="#对-mvvm-的理解" aria-label="Permalink to &quot;对 MVVM 的理解&quot;">​</a></h3><h3 id="computed-特点" tabindex="-1">computed 特点 <a class="header-anchor" href="#computed-特点" aria-label="Permalink to &quot;computed 特点&quot;">​</a></h3><ul><li>缓存，data 不变不会重新计算</li><li>提高性能</li></ul><h3 id="为何组件-data-必须是一个函数" tabindex="-1">为何组件 data 必须是一个函数？ <a class="header-anchor" href="#为何组件-data-必须是一个函数" aria-label="Permalink to &quot;为何组件 data 必须是一个函数？&quot;">​</a></h3><h3 id="ajax-请求应该放在哪个生命周期" tabindex="-1">ajax 请求应该放在哪个生命周期 <a class="header-anchor" href="#ajax-请求应该放在哪个生命周期" aria-label="Permalink to &quot;ajax 请求应该放在哪个生命周期&quot;">​</a></h3><ul><li>mounted</li><li>JS 是单线程的，ajax 异步获取数据</li><li>放在 mounted 之前没有用，只会让逻辑更加混乱</li></ul><h3 id="如何将组件所有-props-传递给组件" tabindex="-1">如何将组件所有 props 传递给组件 <a class="header-anchor" href="#如何将组件所有-props-传递给组件" aria-label="Permalink to &quot;如何将组件所有 props 传递给组件&quot;">​</a></h3><ul><li>$props</li><li><code>&lt;User v-bind=&quot;$props&quot; /&gt;</code></li></ul><h3 id="如何自己实现-v-model" tabindex="-1">如何自己实现 v-model <a class="header-anchor" href="#如何自己实现-v-model" aria-label="Permalink to &quot;如何自己实现 v-model&quot;">​</a></h3><h3 id="多个组件有相同逻辑-如何抽离" tabindex="-1">多个组件有相同逻辑，如何抽离 <a class="header-anchor" href="#多个组件有相同逻辑-如何抽离" aria-label="Permalink to &quot;多个组件有相同逻辑，如何抽离&quot;">​</a></h3><ul><li>mixin</li><li>缺点</li></ul><h3 id="何时要使用异步组件" tabindex="-1">何时要使用异步组件 <a class="header-anchor" href="#何时要使用异步组件" aria-label="Permalink to &quot;何时要使用异步组件&quot;">​</a></h3><ul><li>加载大组件</li><li>路由异步组件</li></ul><h3 id="何时需要使用-keep-alive" tabindex="-1">何时需要使用 keep-alive <a class="header-anchor" href="#何时需要使用-keep-alive" aria-label="Permalink to &quot;何时需要使用 keep-alive&quot;">​</a></h3><ul><li>缓存组件，不需要重复渲染</li><li>如多个静态 tab 页的切换</li><li>优化性能</li></ul><h3 id="何时需要使用-beforedestory" tabindex="-1">何时需要使用 beforeDestory <a class="header-anchor" href="#何时需要使用-beforedestory" aria-label="Permalink to &quot;何时需要使用 beforeDestory&quot;">​</a></h3><ul><li>解绑自定义事件 event.$off</li><li>清楚定时器</li><li>解绑自定义的DOM事件，如 window scroll 等</li></ul><h3 id="什么是作用域插槽" tabindex="-1">什么是作用域插槽 <a class="header-anchor" href="#什么是作用域插槽" aria-label="Permalink to &quot;什么是作用域插槽&quot;">​</a></h3><h3 id="vuex中-action-和-mutaion-的区别" tabindex="-1">vuex中 action 和 mutaion 的区别 <a class="header-anchor" href="#vuex中-action-和-mutaion-的区别" aria-label="Permalink to &quot;vuex中 action 和 mutaion 的区别&quot;">​</a></h3><ul><li>aciton 中异步处理，mutation 不可以</li><li>mutaion 做原子操作</li><li>action 可以整合多个 mutaion</li></ul><h3 id="vue-router-常用的路由模式" tabindex="-1">vue-router 常用的路由模式 <a class="header-anchor" href="#vue-router-常用的路由模式" aria-label="Permalink to &quot;vue-router 常用的路由模式&quot;">​</a></h3><ul><li>hash 默认</li><li>H5 history(需要服务端支持)</li></ul><h3 id="如何配置-vue-router-异步加载" tabindex="-1">如何配置 vue-router 异步加载 <a class="header-anchor" href="#如何配置-vue-router-异步加载" aria-label="Permalink to &quot;如何配置 vue-router 异步加载&quot;">​</a></h3><p>通过import的方式</p><img src="http://cdn.wangtongmeng.com/20231012194421.png" style="zoom:33%;"><h3 id="请用-vnode-描述一个-dom-结构" tabindex="-1">请用 vnode 描述一个 DOM 结构 <a class="header-anchor" href="#请用-vnode-描述一个-dom-结构" aria-label="Permalink to &quot;请用 vnode 描述一个 DOM 结构&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    className</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="监听-data-变化的核心-api-是什么" tabindex="-1">监听 data 变化的核心 API 是什么 <a class="header-anchor" href="#监听-data-变化的核心-api-是什么" aria-label="Permalink to &quot;监听 data 变化的核心 API 是什么&quot;">​</a></h3><ul><li>Object.defineProperty</li><li>深度监听、数组监听</li><li>缺点</li></ul><h3 id="vue-如何监听数组变化" tabindex="-1">Vue 如何监听数组变化 <a class="header-anchor" href="#vue-如何监听数组变化" aria-label="Permalink to &quot;Vue 如何监听数组变化&quot;">​</a></h3><ul><li>Object.defineProperty 不能监听数组变化</li><li>重新定义原型，重写 push pop 等方法，实现监听</li><li>Proxy 可以原生支持监听数组变化</li></ul><h3 id="请描述响应式原理" tabindex="-1">请描述响应式原理 <a class="header-anchor" href="#请描述响应式原理" aria-label="Permalink to &quot;请描述响应式原理&quot;">​</a></h3><ul><li>监听 data 变化</li><li>组件渲染和更新的流程</li></ul><h3 id="diff-算法的时间复杂度" tabindex="-1">diff 算法的时间复杂度 <a class="header-anchor" href="#diff-算法的时间复杂度" aria-label="Permalink to &quot;diff 算法的时间复杂度&quot;">​</a></h3><ul><li>O(n)</li><li>在O(n^3)基础上做了一些调整</li></ul><h3 id="简述-diff-算法过程" tabindex="-1">简述 diff 算法过程 <a class="header-anchor" href="#简述-diff-算法过程" aria-label="Permalink to &quot;简述 diff 算法过程&quot;">​</a></h3><ul><li>patch(elem, vnode) 和 patch(vnode, newVnode)</li><li>patchVnode 和 addVnodes 和 removeVnodes</li><li>updateChildren (key 的重要性)</li></ul><h3 id="vue-为何是异步渲染-nexttick-何用" tabindex="-1">Vue 为何是异步渲染，$nextTick 何用？ <a class="header-anchor" href="#vue-为何是异步渲染-nexttick-何用" aria-label="Permalink to &quot;Vue 为何是异步渲染，$nextTick 何用？&quot;">​</a></h3><ul><li>异步渲染(以及合并 data修改)，以提高渲染性能</li><li>$nextTick 在 DOM 更新完之后，触发回调</li></ul><h3 id="vue-常见性能优化" tabindex="-1">Vue 常见性能优化 <a class="header-anchor" href="#vue-常见性能优化" aria-label="Permalink to &quot;Vue 常见性能优化&quot;">​</a></h3><ul><li>合理使用 v-show 和 v-if</li><li>合理使用 computed</li><li>v-for 时加 key，以及避免和 v-if 同时使用</li><li>自定义事件、DOM事件及时销毁</li><li>合理使用异步组件</li><li>合理使用 keep-alive</li><li>data 层级不要太深</li><li>使用 vue-loader 在开发环境做模板编译(预编译)</li><li>webpack 层面的优化</li><li>前端通用的性能优化，如图片懒加载</li><li>使用 SSR</li></ul><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2><h2 id="vue3面试题" tabindex="-1">Vue3面试题 <a class="header-anchor" href="#vue3面试题" aria-label="Permalink to &quot;Vue3面试题&quot;">​</a></h2><h3 id="vue3-比-vue2有什么优势" tabindex="-1">Vue3 比 Vue2有什么优势？ <a class="header-anchor" href="#vue3-比-vue2有什么优势" aria-label="Permalink to &quot;Vue3 比 Vue2有什么优势？&quot;">​</a></h3><ul><li>性能更好</li><li>体积更小</li><li>更好的 ts 支持</li><li>更好的代码组织</li><li>更好的逻辑抽离</li><li>更多新功能</li></ul><h3 id="描述-vue3-生命周期" tabindex="-1">描述 Vue3 生命周期 <a class="header-anchor" href="#描述-vue3-生命周期" aria-label="Permalink to &quot;描述 Vue3 生命周期&quot;">​</a></h3><ul><li>Options API 生命周期 <ul><li>BeforeDestroy 改为 beforeUnmount</li><li>Destroyed 改为 unmounted</li><li>其他沿用vue2的生命周期</li></ul></li><li>Composition API 生命周期 <ul><li>setup相当于beforeCreate和created</li></ul></li></ul><h3 id="如何看待-composition-api-和-options-api" tabindex="-1">如何看待 Composition API 和 Options API <a class="header-anchor" href="#如何看待-composition-api-和-options-api" aria-label="Permalink to &quot;如何看待 Composition API 和 Options API&quot;">​</a></h3><ul><li>Composition API 带来了什么 <ul><li>更好的代码组织</li><li>更好的逻辑复用(面试题)</li><li>更好的类型推导</li></ul></li><li>Compostion API 和 Options API 如何选择 <ul><li>不建议共用，容易混乱</li><li>小型项目、业务逻辑简单，用 Options API</li><li>中大型项目、逻辑复杂，用 Composition API</li></ul></li></ul><h3 id="如何理解-ref-toref-和-torefs-1" tabindex="-1">如何理解 ref toRef 和 toRefs <a class="header-anchor" href="#如何理解-ref-toref-和-torefs-1" aria-label="Permalink to &quot;如何理解 ref toRef 和 toRefs&quot;">​</a></h3><p>Ref</p><ul><li>是什么 <ul><li>生成值类型的响应式数据</li><li>可用于模板和 reactive(会自动取值，不需要.value)</li><li>通过 .value修改值</li></ul></li><li>最佳使用方式</li><li>进阶，深入理解</li></ul><p>toRef</p><ul><li>针对一个响应式对象(reactive封装)的prop</li><li>创建一个ref，具有响应式</li><li>两者保持引用关系</li></ul><p>toRefs</p><ul><li>将响应式对象(reactive封装)转换为普通对象</li><li>对象的每个prop 都是对应的ref</li><li>两者保持引用关系</li></ul><p>合成函数返回响应式对象（解构）</p><p><img src="`+i+'" alt="image-20231013075153869"></p><p>最佳使用</p><ul><li>用 reactive 做对象的响应式，用 ref 做值类型响应式</li><li>setup 中返回 toRefs(state)，或者toRef(state, &#39;xxx&#39;)</li><li>ref 的变量命名都用 xxxRef</li><li>合成函数返回响应式对象时，使用 toRefs，方便解构</li></ul><h3 id="vue3-升级了哪些重要的功能" tabindex="-1">Vue3 升级了哪些重要的功能 <a class="header-anchor" href="#vue3-升级了哪些重要的功能" aria-label="Permalink to &quot;Vue3 升级了哪些重要的功能&quot;">​</a></h3><ul><li>createApp</li><li>Emits 属性</li><li>生命周期</li><li>多事件</li><li>Fragment</li><li>移除 .sync</li><li>异步组件的写法</li><li>移除 filter</li><li>Teleport</li><li>Suspense</li><li>Composition API</li></ul><p>createApp</p><img src="'+t+'" alt="image-20231013101122828" style="zoom:33%;"><p>emits属性</p><img src="'+h+'" alt="image-20231013101152098" style="zoom:25%;"><p>多事件处理</p><p><img src="'+n+'" alt="image-20231013101431227"></p><p>Fragment</p><p><img src="'+r+'" alt="image-20231013101501380"></p><p>移除 .sync</p><img src="'+o+'" alt="image-20231013101545880" style="zoom:25%;"><p>异步组件</p><p><img src="'+p+'" alt="image-20231013101640605"></p><p>Teleport</p><img src="'+u+'" alt="image-20231013101854652" style="zoom:25%;"><p>Suspense</p><img src="'+d+'" alt="image-20231013101959000" style="zoom:25%;"><p>Composition API</p><ul><li>reactive</li><li>ref 相关</li><li>readonly</li><li>watch 和 watchEffect</li><li>setup</li><li>生命周期钩子函数</li></ul><h3 id="composition-api-如何实现代码逻辑复用" tabindex="-1">Composition API 如何实现代码逻辑复用 <a class="header-anchor" href="#composition-api-如何实现代码逻辑复用" aria-label="Permalink to &quot;Composition API 如何实现代码逻辑复用&quot;">​</a></h3><ul><li>抽离逻辑代码到一个函数</li><li>函数命名约定为 useXxx格式(React Hooks也是)</li><li>在setup中引用 useXxx 函数</li></ul><h3 id="vue3-如何实现响应式" tabindex="-1">Vue3 如何实现响应式 <a class="header-anchor" href="#vue3-如何实现响应式" aria-label="Permalink to &quot;Vue3 如何实现响应式&quot;">​</a></h3><ul><li><p>回顾 Vue 2.x 的 Object.defineProperty</p><ul><li>缺点 <ul><li>深度监听需要一次性递归</li><li>无法监听新增属性/删除属性(Vue.set Vue.delete)</li><li>无法监听数组，需要特殊处理</li></ul></li></ul></li><li><p>学习 Proxy 语法</p><ul><li>基本使用</li><li>Reflect</li><li>实现响应式</li></ul></li><li><p>Vue3 如何用 Proxy 实现响应式</p><ul><li>深度监听，性能更好(懒监听，用到了才监听)</li><li>可监听新增/删除属性</li><li>可监听数组变化</li></ul></li></ul><p>基本使用</p><img src="'+k+'" alt="image-20231013104301985" style="zoom:25%;"><p>Reflect作用(非考点)</p><ul><li>和 Proxy 能力一一对应</li><li>规范化、标准化、函数式</li><li>代替Object 的工具函数</li></ul><p>总结</p><ul><li>Proxy 能规避 Object.defineProperty 的问题</li><li>Proxy 无法兼容所有浏览器，无法polyfill</li></ul><h3 id="watch-和-watcheffect的区别是什么" tabindex="-1">watch 和 watchEffect的区别是什么 <a class="header-anchor" href="#watch-和-watcheffect的区别是什么" aria-label="Permalink to &quot;watch 和 watchEffect的区别是什么&quot;">​</a></h3><ul><li>两者都可监听 data 属性变化</li><li>watch 需要明确监听哪个属性</li><li>watchEffect 会根据其中的属性，自动监听其变化</li></ul><h3 id="setup-中如何获取组件实例" tabindex="-1">setup 中如何获取组件实例 <a class="header-anchor" href="#setup-中如何获取组件实例" aria-label="Permalink to &quot;setup 中如何获取组件实例&quot;">​</a></h3><ul><li>在 setup 和其他 Composition API 中没有 this</li><li>可通过 getCurrentInstance 获取当前实例</li><li>若使用 Options API 可照常使用 this</li></ul><h3 id="vue3为何比-vue2快" tabindex="-1">Vue3为何比 Vue2快 <a class="header-anchor" href="#vue3为何比-vue2快" aria-label="Permalink to &quot;Vue3为何比 Vue2快&quot;">​</a></h3><p><a href="https://template-explorer.vuejs.org/" target="_blank" rel="noreferrer">https://template-explorer.vuejs.org/</a></p><ul><li>Proxy 响应式</li><li>PatchFlag <ul><li>编译模板时，动态节点做标记</li><li>标记，分为不同的类型，如 TEXT PROPS</li><li>diff算法时，可以区分静态节点，以及不同类型的动态节点</li></ul></li><li>HoistStatic <ul><li>将静态节点的定义，提升到父作用域，缓存起来</li><li>多个相邻的静态节点，会被合并起来</li><li>典型的拿空间换时间的优化策略</li></ul></li><li>CacheHandler <ul><li>缓存事件</li></ul></li><li>SSR 优化 <ul><li>静态节点直接输出，绕过了 vdom</li><li>动态节点，还是需要动态渲染</li></ul></li><li>tree-shaking <ul><li>编译时，根据不同的情况，引入不同的API</li></ul></li></ul><img src="'+c+'" alt="image-20231013205915026" style="zoom:25%;"><p>HoistStatic - options 开启hoits</p><p><img src="'+m+'" alt="image-20231013210718754"></p><p>相邻静态节点很多的时候，会合并</p><p><img src="'+E+`" alt="image-20231013211600883"></p><p>CacheHandler</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clickHandler</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>编译后 - 选择 CacheHandler Options</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { openBlock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _openBlock, createElementBlock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _createElementBlock } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_openBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_createElementBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    onClick: _cache[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_cache[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_ctx.clickHandler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clickHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Check the console for the AST</span></span></code></pre></div><p>SSR</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;span&gt;hello vue3&lt;/span&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;span&gt;hello vue3&lt;/span&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;span&gt;hello vue3&lt;/span&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;span&gt;{{msg}}&lt;/span&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>开启SSR，编译后</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { mergeProps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _mergeProps } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ssrRenderAttrs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ssrRenderAttrs, ssrInterpolate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ssrInterpolate } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue/server-renderer&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ssrRender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_attrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">$options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _cssVars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { style: { color: _ctx.color }}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  _push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`&lt;div\${</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _ssrRenderAttrs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_mergeProps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_attrs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_cssVars</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">))</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  } scope-id&gt;&lt;span scope-id&gt;hello vue3&lt;/span&gt;&lt;span scope-id&gt;hello vue3&lt;/span&gt;&lt;span scope-id&gt;hello vue3&lt;/span&gt;&lt;span scope-id&gt;\${</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _ssrInterpolate</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_ctx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  }&lt;/span&gt;&lt;/div&gt;\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Check the console for the AST</span></span></code></pre></div><h3 id="vite-是什么" tabindex="-1">Vite 是什么 <a class="header-anchor" href="#vite-是什么" aria-label="Permalink to &quot;Vite 是什么&quot;">​</a></h3><ul><li>一个前端打包工具，Vue 作者发起的项目</li><li>优势：开发环境下无需打包，启动快</li><li>为何启动快？ <ul><li>开发环境使用 ES6 Module，无需打包——fzihky</li><li>生产环境使用 rollup，并不会快很多</li></ul></li></ul><h3 id="composition-api-和-react-hooks-的对比" tabindex="-1">Composition API 和 React Hooks 的对比 <a class="header-anchor" href="#composition-api-和-react-hooks-的对比" aria-label="Permalink to &quot;Composition API 和 React Hooks 的对比&quot;">​</a></h3><ul><li>前者 setup 只会被调用一次，而后者函数会被多次调用</li><li>前者无需 useMemo useCallback，因为 setup 只调用一次</li><li>前者无需顾虑调用顺序，而后者需要保证 hooks 的顺序一致</li><li>前者 reactive + ref 比后者 useState，更难理解</li></ul><h2 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to &quot;核心思想&quot;">​</a></h2><h3 id="说说你对双向绑定的理解-以及它的实现原理" tabindex="-1">说说你对双向绑定的理解，以及它的实现原理 <a class="header-anchor" href="#说说你对双向绑定的理解-以及它的实现原理" aria-label="Permalink to &quot;说说你对双向绑定的理解，以及它的实现原理&quot;">​</a></h3><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h2><h3 id="v-if和v-for哪个优先级更高" tabindex="-1">v-if和v-for哪个优先级更高？ <a class="header-anchor" href="#v-if和v-for哪个优先级更高" aria-label="Permalink to &quot;v-if和v-for哪个优先级更高？&quot;">​</a></h3><h3 id="vue组件data为什么必须是个函数" tabindex="-1">Vue组件data为什么必须是个函数？ <a class="header-anchor" href="#vue组件data为什么必须是个函数" aria-label="Permalink to &quot;Vue组件data为什么必须是个函数？&quot;">​</a></h3><h3 id="函数组件的优势" tabindex="-1">函数组件的优势 <a class="header-anchor" href="#函数组件的优势" aria-label="Permalink to &quot;函数组件的优势&quot;">​</a></h3><h3 id="vue中的过滤器了解吗-过滤器的应用场景有哪些" tabindex="-1">Vue中的过滤器了解吗？过滤器的应用场景有哪些？ <a class="header-anchor" href="#vue中的过滤器了解吗-过滤器的应用场景有哪些" aria-label="Permalink to &quot;Vue中的过滤器了解吗？过滤器的应用场景有哪些？&quot;">​</a></h3><h3 id="v-once的使用场景有哪些" tabindex="-1">v-once的使用场景有哪些 <a class="header-anchor" href="#v-once的使用场景有哪些" aria-label="Permalink to &quot;v-once的使用场景有哪些&quot;">​</a></h3><h3 id="vue中-sync修饰符的作用" tabindex="-1">Vue中.sync修饰符的作用？ <a class="header-anchor" href="#vue中-sync修饰符的作用" aria-label="Permalink to &quot;Vue中.sync修饰符的作用？&quot;">​</a></h3><h3 id="vue中slot是如何实现的-什么时候使用它" tabindex="-1">Vue中slot是如何实现的？什么时候使用它？ <a class="header-anchor" href="#vue中slot是如何实现的-什么时候使用它" aria-label="Permalink to &quot;Vue中slot是如何实现的？什么时候使用它？&quot;">​</a></h3><h3 id="vue-use是干什么的" tabindex="-1">Vue.use是干什么的？ <a class="header-anchor" href="#vue-use是干什么的" aria-label="Permalink to &quot;Vue.use是干什么的？&quot;">​</a></h3><h3 id="vue-extend方法的作用" tabindex="-1">Vue.extend方法的作用？ <a class="header-anchor" href="#vue-extend方法的作用" aria-label="Permalink to &quot;Vue.extend方法的作用？&quot;">​</a></h3><h3 id="vue-mixin的使用场景和原理" tabindex="-1">Vue.mixin的使用场景和原理 <a class="header-anchor" href="#vue-mixin的使用场景和原理" aria-label="Permalink to &quot;Vue.mixin的使用场景和原理&quot;">​</a></h3><h3 id="vue中递归组件理解" tabindex="-1">Vue中递归组件理解 <a class="header-anchor" href="#vue中递归组件理解" aria-label="Permalink to &quot;Vue中递归组件理解&quot;">​</a></h3><h3 id="组件中写name选项有哪些好处及作用" tabindex="-1">组件中写name选项有哪些好处及作用？ <a class="header-anchor" href="#组件中写name选项有哪些好处及作用" aria-label="Permalink to &quot;组件中写name选项有哪些好处及作用？&quot;">​</a></h3><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><h3 id="vue的生命周期方法有哪些-一般在哪一步发送请求及原因" tabindex="-1">Vue的生命周期方法有哪些？一般在哪一步发送请求及原因 <a class="header-anchor" href="#vue的生命周期方法有哪些-一般在哪一步发送请求及原因" aria-label="Permalink to &quot;Vue的生命周期方法有哪些？一般在哪一步发送请求及原因&quot;">​</a></h3><h2 id="diff算法" tabindex="-1">Diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;Diff算法&quot;">​</a></h2><h3 id="vue中diff算法原理" tabindex="-1">Vue中diff算法原理 <a class="header-anchor" href="#vue中diff算法原理" aria-label="Permalink to &quot;Vue中diff算法原理&quot;">​</a></h3><h3 id="请说明vue中key的作用和原理-谈谈你对它的理解" tabindex="-1">请说明Vue中key的作用和原理，谈谈你对它的理解 <a class="header-anchor" href="#请说明vue中key的作用和原理-谈谈你对它的理解" aria-label="Permalink to &quot;请说明Vue中key的作用和原理，谈谈你对它的理解&quot;">​</a></h3><h2 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h2><h2 id="数据管理" tabindex="-1">数据管理 <a class="header-anchor" href="#数据管理" aria-label="Permalink to &quot;数据管理&quot;">​</a></h2><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2>`,283),v=[g];function b(y,q,x,P,F,V){return e(),a("div",null,v)}const _=l(f,[["render",b]]);export{C as __pageData,_ as default};
