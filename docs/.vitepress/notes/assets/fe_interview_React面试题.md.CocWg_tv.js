import{_ as s,c as i,o as a,a4 as l}from"./chunks/framework.C5rzuSi5.js";const o=JSON.parse('{"title":"React 面试题1","description":"","frontmatter":{},"headers":[],"relativePath":"fe/interview/React面试题.md","filePath":"fe/interview/React面试题.md","lastUpdated":null}'),n={name:"fe/interview/React面试题.md"},t=l(`<h1 id="react-面试题1" tabindex="-1">React 面试题1 <a class="header-anchor" href="#react-面试题1" aria-label="Permalink to &quot;React 面试题1&quot;">​</a></h1><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h2><h3 id="组件之间如何通讯" tabindex="-1">组件之间如何通讯？ <a class="header-anchor" href="#组件之间如何通讯" aria-label="Permalink to &quot;组件之间如何通讯？&quot;">​</a></h3><ul><li>父子组件 props</li><li>自定义事件</li><li>Redux 和 Context</li></ul><h3 id="context-是什么-如何应用" tabindex="-1">Context 是什么，如何应用？ <a class="header-anchor" href="#context-是什么-如何应用" aria-label="Permalink to &quot;Context 是什么，如何应用？&quot;">​</a></h3><ul><li>父组件，向它的所有子孙组件传递信息</li><li>如一些简单的公共信息：主题色、语言等</li><li>复杂的公共信息，请用 redux、mobx</li></ul><h3 id="shouldcomponentupdate-用途" tabindex="-1">shouldComponentUpdate 用途 <a class="header-anchor" href="#shouldcomponentupdate-用途" aria-label="Permalink to &quot;shouldComponentUpdate 用途&quot;">​</a></h3><ul><li>性能优化</li><li>配合“不可变值”一起使用，否则会出错</li></ul><h3 id="什么是纯函数" tabindex="-1">什么是纯函数？ <a class="header-anchor" href="#什么是纯函数" aria-label="Permalink to &quot;什么是纯函数？&quot;">​</a></h3><ul><li>返回一个新值，没有副作用（不会“偷偷”修改其他值）</li><li>重点：不可变值</li><li>如 arr1 = arr.slice()</li></ul><h3 id="react-组件生命周期" tabindex="-1">React 组件生命周期 <a class="header-anchor" href="#react-组件生命周期" aria-label="Permalink to &quot;React 组件生命周期&quot;">​</a></h3><ul><li>单组件生命周期</li><li>父子组件生命周期</li><li>注意 SCU</li></ul><h3 id="react-发起-ajax-应该在那个生命周期" tabindex="-1">React 发起 ajax 应该在那个生命周期 <a class="header-anchor" href="#react-发起-ajax-应该在那个生命周期" aria-label="Permalink to &quot;React 发起 ajax 应该在那个生命周期&quot;">​</a></h3><ul><li>同 Vue</li><li>componentDidMount</li></ul><h3 id="函数组件和-class-组件的区别" tabindex="-1">函数组件和 class 组件的区别 <a class="header-anchor" href="#函数组件和-class-组件的区别" aria-label="Permalink to &quot;函数组件和 class 组件的区别&quot;">​</a></h3><ul><li>纯函数，输入 props，输出 JSX</li><li>没有实例，没有生命周期，没有 state</li><li>不能扩展其他方法</li></ul><h3 id="什么是受控组件" tabindex="-1">什么是受控组件？ <a class="header-anchor" href="#什么是受控组件" aria-label="Permalink to &quot;什么是受控组件？&quot;">​</a></h3><ul><li>表单的值，受 state 控制</li><li>需要自行监听 onChange，更新 state</li><li>对比非受控组件</li></ul><h3 id="多个组件有公共逻辑-如何抽离" tabindex="-1">多个组件有公共逻辑，如何抽离 <a class="header-anchor" href="#多个组件有公共逻辑-如何抽离" aria-label="Permalink to &quot;多个组件有公共逻辑，如何抽离&quot;">​</a></h3><ul><li>高阶组件 HOC</li><li>Render Props</li></ul><h3 id="react-事件和-dom-事件的区别" tabindex="-1">React 事件和 DOM 事件的区别 <a class="header-anchor" href="#react-事件和-dom-事件的区别" aria-label="Permalink to &quot;React 事件和 DOM 事件的区别&quot;">​</a></h3><ul><li>所有事件都挂载到 document(React &gt;= 17后，挂载到 root 上) 上</li><li>event 不是原生的，是 SyntheticEvent 合成事件对象</li><li>dispatchEvent</li></ul><h2 id="性能优化相关" tabindex="-1">性能优化相关 <a class="header-anchor" href="#性能优化相关" aria-label="Permalink to &quot;性能优化相关&quot;">​</a></h2><h3 id="渲染列表-为何使用-key" tabindex="-1">渲染列表，为何使用 key <a class="header-anchor" href="#渲染列表-为何使用-key" aria-label="Permalink to &quot;渲染列表，为何使用 key&quot;">​</a></h3><ul><li>同 Vue。必须用 key，且不能是 index 和 random</li><li>diff 算法中通过 tag 和 key 来判断，是否是 sameNode</li><li>减少渲染次数，提高渲染性能</li></ul><h3 id="purecomponent-有何区别" tabindex="-1">PureComponent 有何区别 <a class="header-anchor" href="#purecomponent-有何区别" aria-label="Permalink to &quot;PureComponent 有何区别&quot;">​</a></h3><ul><li>实现浅比较的 shouldComponentUpdate</li><li>性能优化</li><li>但要结合不可变值使用</li></ul><h3 id="何时使用异步组件" tabindex="-1">何时使用异步组件 <a class="header-anchor" href="#何时使用异步组件" aria-label="Permalink to &quot;何时使用异步组件&quot;">​</a></h3><ul><li>同 Vue</li><li>加载大组件</li><li>路由懒加载</li></ul><h3 id="react-性能优化" tabindex="-1">React 性能优化 <a class="header-anchor" href="#react-性能优化" aria-label="Permalink to &quot;React 性能优化&quot;">​</a></h3><ul><li>渲染列表时 使用 key</li><li>自定义事件、DOM 事件及时销毁</li><li>合理使用异步组件</li><li>减少函数 bind this 的次数</li><li>合理使用 SCU PureComponent 和 memo</li><li>合理使用 Immutable.js</li><li>webpack 层面的优化</li><li>前端通用的性能优化，如图片懒加载</li><li>使用 SSR</li></ul><h2 id="数据管理" tabindex="-1">数据管理 <a class="header-anchor" href="#数据管理" aria-label="Permalink to &quot;数据管理&quot;">​</a></h2><h3 id="redux-单项数据流" tabindex="-1">redux 单项数据流 <a class="header-anchor" href="#redux-单项数据流" aria-label="Permalink to &quot;redux 单项数据流&quot;">​</a></h3><img src="http://cdn.wangtongmeng.com/20240617150707.png" style="zoom:33%;"><h3 id="redux-如何进行异步请求" tabindex="-1">redux 如何进行异步请求 <a class="header-anchor" href="#redux-如何进行异步请求" aria-label="Permalink to &quot;redux 如何进行异步请求&quot;">​</a></h3><ul><li>使用异步 action</li><li>如何 redux-thunk</li></ul><h2 id="路由管理" tabindex="-1">路由管理 <a class="header-anchor" href="#路由管理" aria-label="Permalink to &quot;路由管理&quot;">​</a></h2><h3 id="react-router-如何配置懒加载" tabindex="-1">react-router 如何配置懒加载 <a class="header-anchor" href="#react-router-如何配置懒加载" aria-label="Permalink to &quot;react-router 如何配置懒加载&quot;">​</a></h3><img src="http://cdn.wangtongmeng.com/20240617153958.png" style="zoom:33%;"><h2 id="场景题" tabindex="-1">场景题 <a class="header-anchor" href="#场景题" aria-label="Permalink to &quot;场景题&quot;">​</a></h2><h3 id="setstate-场景题" tabindex="-1">setState 场景题 <a class="header-anchor" href="#setstate-场景题" aria-label="Permalink to &quot;setState 场景题&quot;">​</a></h3><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      val: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  componentDidMount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({val: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第 1 次 log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({val: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第 2 次 log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({val: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第 3 次 log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({val: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.val);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第 4 次 log</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>React 16</p><blockquote><p>1 0 2 0 3 2 4 3</p></blockquote><p>React 18，都是批量更新的了</p><blockquote><p>1 0 2 0 1 0 2 0 3 1 4 1 3 1 4 1</p></blockquote><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><h3 id="jsx-的本质" tabindex="-1">JSX 的本质 <a class="header-anchor" href="#jsx-的本质" aria-label="Permalink to &quot;JSX 的本质&quot;">​</a></h3><p>到 <code>https://www.babeljs.cn/</code> 做一个测试，将以下 jsx 编译为 js</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX 基本用法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> imgElem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;some text&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{imgUrl}/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX style</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> styleData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fontSize: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;30px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  color: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;blue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> styleElem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{styleData}&gt;设置 style&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX 加载组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submitTitle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{onSubmitTitle}/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{list}/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX 事件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eventList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.clickHandler}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    some text</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX list</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> listElem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state.list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id}&gt;index {index}; title {item.title}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>以上可见，<code>React.createElement</code> 就相当于 vue中的 <code>h</code> 函数，执行则会返回一个 vnode 结构。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或是一个组件名 Input List 等</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或 &#39;...&#39; 其中只有文本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>看 React.createElement 的第一个参数</p><ul><li>渲染 html 标签时，就是一个字符串， div p img 等</li><li>渲染组件时，就是一个组件，Input List 等</li><li>React 规定，所有的组件必须大写字母开头，因为 html 标签都是小写字母开头 —— 这样就很好识别 jsx 标签是一个 html tag 还是自定义组件。</li></ul><p>如果第一个参数是组件，那就继续去寻找该组件的 render 函数中的 jsx 结构，直到找到最底层，即 html tag 。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个参数是 List 组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list: list</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 找到 List 组件 jsx 结构，继续拆分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                key: item.id</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;title &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, item.title)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>总结一下</p><ul><li>JSX 是 React.createElement 的语法糖</li><li>React.createElement 最终返回 vnode</li><li>其中遇到自定义组件，会继续找其 jsx 结构，继续渲染</li></ul><p>最后，将 vnode 结构渲染为 elem ，之前已经讲过，React 这里的过程也是一样的。 React 将组件分为四个类型，分别进行渲染。</p><ul><li>ReactEmptyComponent - 空组件 null undefined</li><li>ReactDOMComponent - html 节点</li><li>ReactTextComponent - 文本组件</li><li>ReactCompositeComponent - 自定义组件</li></ul><hr><h3 id="事件机制" tabindex="-1">事件机制 <a class="header-anchor" href="#事件机制" aria-label="Permalink to &quot;事件机制&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clickHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stopPropagation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;target&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.target) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指向当前元素，即当前元素触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;current target&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.currentTarget) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指向当前元素，假象！！！</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注意，event 其实是 React 封装的。可以看 __proto__.constructor 是 SyntheticEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;event&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 原生 event 如下。其 __proto__.constructor 是 MouseEvent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nativeEvent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.nativeEvent)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 指向当前元素，即当前元素触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nativeEvent target&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.nativeEvent.target)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 指向 document ！！！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nativeEvent current target&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.nativeEvent.currentTarget)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过之前的使用，可以得出</p><ul><li>1.React 将所有时间都挂载到 document 上（react &lt;= 17），react17绑定在根节点上</li><li>2.event 不是原生的，是 SyntheticEvent 合成事件</li></ul><p>React 自己实现了一套事件机制 —— 合成事件机制</p><ul><li>事件的绑定和销毁</li><li>事件的触发和冒泡</li><li>3.和 DOM 事件不一样</li></ul><p>React 事件机制的实现流程</p><ul><li>示意图</li><li>diapatchEvent</li><li>JSX 渲染时，能知道每个事件和组件的关系，也就能触发到该组件的事件函数</li></ul><p>为什么要这样做？</p><ul><li>为了兼容性和跨平台（仅仅是将事件挂载到 document ，其他都不依赖于 DOM 事件，很独立）</li><li>挂载到 document ，减少内存消耗，方便事件绑定和解绑（不用再用 removeListener）</li><li>方便对事件的统一管理，如事务机制 —— 下文介绍</li></ul><p>React 17 事件绑定到 root</p><ul><li>React 16 绑定到 document</li><li>React 17 事件绑定到 root 组件</li><li>有利于多个 React 版本并存，例如微前端</li></ul><hr><h3 id="setstate-和-batchupdate" tabindex="-1">setState 和 batchUpdate <a class="header-anchor" href="#setstate-和-batchupdate" aria-label="Permalink to &quot;setState 和 batchUpdate&quot;">​</a></h3><p>根据之前对 setState 的应用，发现</p><ul><li>有时异步，有时同步（不受 React 控制的函数中，是同步）</li><li>连续执行多次 setState ，只会更新一次（异步情况下）</li><li>传入对象时，会被合并</li></ul><p>这部分过程非常复杂，如果从源码入手，反而不太容易讲清楚。另外，由于细节过于复杂，所以再难的面试也不可能考察到那么细致的源码。<strong>所以，我们只需要了解这部分的流程和重点，应对面试应该没有问题</strong>。</p><p>这部分的重要知识点：</p><ul><li>setState 主流程</li><li>batchUpdate 机制</li><li>transaction 机制</li></ul><p>（解释什么是“事务”，例如数据库的事务操作。即将一组操作当做一个原子操作，例如银行转账）</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transaction.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initialize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;initialize&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transaction.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;close&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;abc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transaction.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(method)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;initialize&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;abc&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;close&#39;</span></span></code></pre></div><p>哪些场景会命中 batchUpdate 机制？</p><ul><li>生命周期</li><li>React 事件</li></ul><p>哪些不会命中 batchUpdate 机制？</p><ul><li>setTimeout 等全局函数</li><li>自己定义的 DOM 事件</li></ul><p>总结 setState 的特点</p><ul><li>单独看 setState 本身，无所谓同步和异步</li><li>同步还是异步，取决于是否命中 batchUpdate 机制</li><li>通过事务机制，控制 isBatchingUpdates</li></ul><img src="http://cdn.wangtongmeng.com/20240617143419.png" style="zoom:33%;"><p>transaction 机制</p><img src="http://cdn.wangtongmeng.com/20240617144409.png" style="zoom:33%;"><h3 id="组件渲染、更新和-diff-算法" tabindex="-1">组件渲染、更新和 diff 算法 <a class="header-anchor" href="#组件渲染、更新和-diff-算法" aria-label="Permalink to &quot;组件渲染、更新和 diff 算法&quot;">​</a></h3><p>回顾 vdom 的重点知识。</p><p>遍历 dirtyComponents 进行更新，组件更新依赖于 vdom 和 diff 算法。</p><ul><li>根据 newProps 和 newState 执行 render 函数</li><li>生成 newVnode</li><li>patch(vnode, newVnode) —— 这里并不是一步完成，React 会有更详细的优化，但最终结果和 patch 一样。</li></ul><p>更新是分为两个阶段</p><ul><li>reconciliation 阶段。对 dirtyComponent 以及子组件进行 diff ，找出变化部分。这个阶段可以拆分为多个子任务，可以随时暂停和恢复。—— 至于为何要拆分，继续往下看。</li><li>commit 阶段。对当前 diff 获取的变化部分，进行 DOM 操作。一次性执行完成，不能拆分。</li></ul><p>暴露性能问题 —— <strong>注意，是在某些复杂的情况下，你不一定能遇到！</strong></p><ul><li>JS 是单线程，而且和 DOM 渲染共用一个线程</li><li>当前项目复杂、组件数量多时，组件更新将占据大量 JS 计算</li><li>此时，如果再有其他的 DOM 渲染需求（如动画、频繁的鼠标键盘操作），将会导致卡顿</li></ul><p>解决方案 —— fiber （React 16 之后引入 fiber 架构）</p><ul><li>对 reconciliation 阶段进行任务拆分，可暂停，可恢复</li><li>当有 DOM 渲染需求时暂停，空闲时再恢复</li><li>如何判断浏览器空闲？—— window.requestIdleCallback <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</a></li></ul><p>注意，fiber 是 React 内部的运行机制，作为使用者体会不到，甚至有些情况都触发不到 fiber 机制。但是我们得知道它的基本情况：what why how</p><h2 id="框架对比" tabindex="-1">框架对比 <a class="header-anchor" href="#框架对比" aria-label="Permalink to &quot;框架对比&quot;">​</a></h2><h3 id="react-和-vue-的区别" tabindex="-1">React 和 Vue 的区别 <a class="header-anchor" href="#react-和-vue-的区别" aria-label="Permalink to &quot;React 和 Vue 的区别&quot;">​</a></h3><p>相同点</p><ul><li>都支持组件化</li><li>都是数据驱动视图</li><li>都使用 vdom 操作 DOM</li></ul><p>不同点</p><ul><li>React 使用 JSX 拥抱 JS，Vue 使用模板拥抱 html</li><li>React 函数式编程，Vue 声明式编程</li><li>React 更多需要自力更生，Vue 把想要的都给你</li></ul>`,108),h=[t];function e(p,k,E,r,d,g){return a(),i("div",null,h)}const y=s(n,[["render",e]]);export{o as __pageData,y as default};
