import{_ as l,c as i,o as a,a4 as e}from"./chunks/framework.C5rzuSi5.js";const o="/assets/image-20231014061832704.BVmP8k9P.png",t="/assets/image-20231015074208334.C6zcFvAL.png",s="/assets/image-20231015084025529.FuMD-6yM.png",r="/assets/image-20231014191204868.CRL3cH-b.png",n="/assets/image-20231014192644213.D2A0hZkW.png",p="/assets/image-20231014193856648.DiV2rbaq.png",u="/assets/image-20231015070459001.B9X0uJ7u.png",b="/assets/image-20231015070615681.DNcsNxQv.png",c="/assets/image-20231015070836502.BPg_Kita.png",h="/assets/image-20231015084534908.CXl2q4hj.png",S=JSON.parse('{"title":"webpack","description":"","frontmatter":{},"headers":[],"relativePath":"fe/interview/webpack.md","filePath":"fe/interview/webpack.md","lastUpdated":1699668135000}'),d={name:"fe/interview/webpack.md"},k=e('<h1 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h1><ul><li><p>webpack 前端打包必备</p></li><li><p>每日必用，面试必考</p></li><li><p>成熟的工具，重点在于配置和使用，原理并不高优</p></li></ul><p>内容</p><ul><li>基本配置 <ul><li>安装配置</li><li>dev-server</li><li>解析 ES6</li><li>解析样式</li><li>解析图片文件</li><li>常见 loader 和 plugin</li></ul></li><li>高级配置 <ul><li>多入口</li><li>抽离和压缩 css</li><li>抽离公共代码</li><li>懒加载</li><li>处理 React 和 Vue</li></ul></li><li>优化打包效率 <ul><li>优化 babel-loader</li><li>IgnoreLoader</li><li>noParse</li><li>happyhack</li><li>ParallelUglifyPlugin</li><li>自动刷新</li><li>热更新</li><li>DllPlugin</li></ul></li><li>优化产出代码 <ul><li>使用生产环境</li><li>小图片 base64 编码</li><li>bundle 加 hash</li><li>使用 CDN</li><li>提取公共代码</li><li>懒加载</li><li>scope hosting</li></ul></li><li>构建流程概述</li><li>babel <ul><li>polyfill</li><li>runtime</li></ul></li></ul><p>webpack4升级webpack5</p><p><img src="'+o+'" alt="image-20231014061832704"></p><h2 id="基本配置" tabindex="-1">基本配置 <a class="header-anchor" href="#基本配置" aria-label="Permalink to &quot;基本配置&quot;">​</a></h2><ul><li>拆分配置和 merge</li><li>启动本地服务 <strong>webpack-dev-server html-webpack-plugin</strong></li><li>处理 ES6 @babel/core @babel/preset-env <strong>babel-loader</strong></li><li>处理样式 <strong>style-loader css-loader less-loader postcss-loader</strong> autoprefixer</li><li>处理图片 <strong>file-loader url-loader</strong></li><li>模块化，webpack本身支持，但需要引入webpack</li></ul><h2 id="高级配置" tabindex="-1">高级配置 <a class="header-anchor" href="#高级配置" aria-label="Permalink to &quot;高级配置&quot;">​</a></h2><blockquote><ul><li>基本配置只能做 demo，不能做线上项目</li><li>面试官考察基本配置，是为了判断是否用过 webpack</li><li>高级配置，也是通过面试的必要条件</li></ul></blockquote><ul><li>多入口</li><li>抽离 CSS 文件 mini-css-extract-plugin 压缩css terser-webpack-plugin optimize-css-assets-webpack-plugin</li><li>抽离公共代码，配置splitChunks</li><li>懒加载</li><li>处理 JSX，用 babel</li><li>处理 Vue，用 vue-loader</li></ul><h2 id="优化打包效率" tabindex="-1">优化打包效率 <a class="header-anchor" href="#优化打包效率" aria-label="Permalink to &quot;优化打包效率&quot;">​</a></h2><ul><li>Webpack 优化构建速度(可用于生产环境) <ul><li>优化 babel-loader</li><li>IgnorePlugin</li><li>noParse</li><li>happyPack</li><li>PrallelUglifyPlugin</li></ul></li><li>Webpack 优化构建速度(不可用于生产环境！) <ul><li>自动刷新</li><li>热更新</li><li>DllPlugin</li></ul></li></ul><h2 id="优化产出代码" tabindex="-1">优化产出代码 <a class="header-anchor" href="#优化产出代码" aria-label="Permalink to &quot;优化产出代码&quot;">​</a></h2><blockquote><ul><li>体积更小</li><li>合理分包，不重复加载</li><li>速度更快、内存使用更小</li></ul></blockquote><ul><li>小图片 base64 编码</li><li>bundle加hash</li><li>懒加载</li><li>提取公共代码</li><li>IgnorePlugin</li><li>使用 CDN 加速，1.output设置publicPath cdn地址 2.将打包好的文件上传至cdn服务器上去。对于图片可以设置url-loader的publicPath</li><li>使用 production <ul><li>自动开启代码压缩</li><li>Vue React 等会自动删掉调试代码(如开发环境的 warning)</li><li>启用 tree-shaking（ES6 module 才能让 tree-shaking生效，commonjs不行） <ul><li>ES6 Module 和 Commonjs 区别 <ul><li>ES6 Module 静态引入，编译时引入</li><li>Commonjs 动态引入，执行时引入</li><li>只有静态引用才能实现 Tree-Shaking</li></ul></li></ul></li></ul></li><li>Scope Hosting <ul><li>代码体积更小</li><li>创建函数作用域更少</li><li>代码可读性更好</li></ul></li></ul><h2 id="构建流程概述" tabindex="-1">构建流程概述 <a class="header-anchor" href="#构建流程概述" aria-label="Permalink to &quot;构建流程概述&quot;">​</a></h2><h2 id="babel" tabindex="-1">babel <a class="header-anchor" href="#babel" aria-label="Permalink to &quot;babel&quot;">​</a></h2><blockquote><ul><li>前端开发环境必备工具</li><li>同 webpack，需要了解基本的配置和使用</li><li>面试考察概率不高，但要求必会</li></ul></blockquote><ul><li>环境搭建 &amp; 基本配置 <ul><li>环境搭建</li><li>.babelrc 配置</li><li>presets 和 plugins</li></ul></li><li>babel-polyfill <ul><li>什么是 Polyfill</li><li>core-js(支持所有es6+语法，除了generatoer) 和 regenerator(支持generatoer语法)</li><li>babel-polyfill即两者的集合</li><li>babel-polyfill现已被废弃 <ul><li>Babel 7.4 之后弃用 babel-polyfill</li><li>推荐直接用 core-js 和 regenerator</li><li>但不影响面试考察它</li></ul></li><li>babel-polyfill 按需引入 <ul><li>文件较大</li><li>只有一部分功能，无需全部引入</li><li>配置按需引入</li><li><img src="'+t+'" alt="image-20231015074208334" style="zoom:25%;"></li><li>babel-polyfill 的问题 <ul><li>会污染全局环境</li><li>如果做一个独立的 web 系统，则无碍</li><li>如果做一个第三方 lib，则会有问题</li><li>使用 babel-runtime重新命名，不会污染全局环境</li></ul></li></ul></li></ul></li><li>babel-runtime</li></ul><h2 id="webpack面试题" tabindex="-1">webpack面试题 <a class="header-anchor" href="#webpack面试题" aria-label="Permalink to &quot;webpack面试题&quot;">​</a></h2><h3 id="前端代码为何要进行构建和打包" tabindex="-1">前端代码为何要进行构建和打包 <a class="header-anchor" href="#前端代码为何要进行构建和打包" aria-label="Permalink to &quot;前端代码为何要进行构建和打包&quot;">​</a></h3><p>代码层面</p><ul><li>体积更小（Tree-shaking、压缩、合并），加载更快</li><li>编译高级语言或语法（TS，ES6+，模块化，scss）</li><li>兼容性和错误检查（Polyfill、postcss、eslint）</li></ul><p>工程化团队协作层面</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h3 id="webpack如何实现懒加载" tabindex="-1">webpack如何实现懒加载 <a class="header-anchor" href="#webpack如何实现懒加载" aria-label="Permalink to &quot;webpack如何实现懒加载&quot;">​</a></h3><ul><li>import()</li><li>结合 Vue React 异步组件</li><li>结合 Vue-router React-router 异步加载路由</li></ul><h3 id="说说对webpack的理解" tabindex="-1">说说对webpack的理解 <a class="header-anchor" href="#说说对webpack的理解" aria-label="Permalink to &quot;说说对webpack的理解&quot;">​</a></h3><h3 id="webpack的构建流程" tabindex="-1">webpack的构建流程 <a class="header-anchor" href="#webpack的构建流程" aria-label="Permalink to &quot;webpack的构建流程&quot;">​</a></h3><p>几个核心概念</p><ul><li>Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</li><li>Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li>Loader：模块转换器，用于把模块原内容按照需求转换成新内容。</li><li>Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li></ul><p>Webpack 的构建流程可以分为以下三大阶段：</p><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。</li><li>编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。</li><li>输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</li></ul><h3 id="常用的loader和plugin" tabindex="-1">常用的Loader和Plugin <a class="header-anchor" href="#常用的loader和plugin" aria-label="Permalink to &quot;常用的Loader和Plugin&quot;">​</a></h3><img src="'+s+'" alt="image-20231015084025529" style="zoom:25%;"><p>常用的要答出来</p><p>loader</p><ul><li>css：sass-loader、css-loader、style-loader（开发环境）、postcss-loader</li><li>js：babel-loader</li><li>图片： file-loader url-loader</li></ul><p>plugin</p><ul><li>html 模板 html-webpack-plugin</li><li>每次打包清理Bundle， clean-webpack-plugin</li><li>代码压缩 minCssExtracPlugin</li><li>多进程：多进程打包happypack、多进程压缩ParallelUglifyPlugin</li><li>DllPlugin：动态链接库，配合DllReferencePlugin</li></ul><h3 id="loader和plugin的区别" tabindex="-1">Loader和Plugin的区别 <a class="header-anchor" href="#loader和plugin的区别" aria-label="Permalink to &quot;Loader和Plugin的区别&quot;">​</a></h3><ul><li>loader 模块转换器，如 less -&gt; css</li><li>plugin 扩展插件，如 HtmlWebpackPlugin</li></ul><h3 id="编写loader和plugin" tabindex="-1">编写Loader和Plugin <a class="header-anchor" href="#编写loader和plugin" aria-label="Permalink to &quot;编写Loader和Plugin&quot;">​</a></h3><h3 id="bundle、chunk-module的区别" tabindex="-1">bundle、chunk，module的区别 <a class="header-anchor" href="#bundle、chunk-module的区别" aria-label="Permalink to &quot;bundle、chunk，module的区别&quot;">​</a></h3><ul><li>Module - 各个源码文件，webpack 中一切皆模块</li><li>chunk - 多模块合成的，如 entry 入口及其依赖、 import()异步加载文件及其依赖、 splitchunk 代码拆分文件</li><li>bundle - 最终的输出文件</li></ul><h3 id="webpack热更新实现原理" tabindex="-1">webpack热更新实现原理 <a class="header-anchor" href="#webpack热更新实现原理" aria-label="Permalink to &quot;webpack热更新实现原理&quot;">​</a></h3><h3 id="webpack常见性能优化-重点" tabindex="-1">webpack常见性能优化（重点） <a class="header-anchor" href="#webpack常见性能优化-重点" aria-label="Permalink to &quot;webpack常见性能优化（重点）&quot;">​</a></h3><ul><li><p>大厂必考 &amp; 社区热议话题</p></li><li><p>优化打包构建速度 - 开发体验和效率</p><ul><li>优化 babel-loader，1.开启缓存，只要es6代码没变就不会重新编译，2.通过include明确范围</li><li>IginorePlugin，避免引入无用模块 <ul><li>import moment from &#39;moment&#39;</li><li>默认会引入所有语言 JS 代码，代码过大</li><li>如何只引入中文？</li></ul></li><li>noParse <ul><li>IgnorePlugin vs noParse <ul><li>IgnorePlugin 直接不引入，代码中没有</li><li>noParse 引入，但不打包</li></ul></li></ul></li><li>happyPack 多进程打包 <ul><li>JS 单线程，开启多进程打包</li><li>提高构建速度(特别是多喝 CPU)</li></ul></li><li>ParallelUglifyPlugin 多进程压缩 JS <ul><li>webpack 内置 Uglify 工具压缩 JS</li><li>JS 单线程，开启多进程压缩更快</li><li>和 happyPack 同理</li><li>关于开启多进程 <ul><li>项目较大，打包较慢，开启多进程能提高速度</li><li>项目较小，打包很快，开启多进程会降低速度(进程开销)</li><li>按需使用</li></ul></li></ul></li><li>自动刷新</li><li>热更新 <ul><li>自动刷新：整个网页全部刷新，速度较慢</li><li>自动刷新：整个网页全部刷新，状态会丢失</li><li>热更新：新代码生效，网页不刷新，状态不丢失</li><li>如果不影响开发用网页刷新，否则用热更新(成本大一些)</li></ul></li><li>DllPlugin 动态链接库插件 <ul><li>前端框架如 vue react ，体积大，构建慢</li><li>较稳定，不常升级版本</li><li>同一个版本只构建一次即可，不用每次都重新构建</li><li>webpack 已内置 DllPlugin 支持</li><li>DllPlugin - 打包出 dll 文件</li><li>DllReferencePlugin - 使用 dll 文件</li></ul></li><li>Webpack 优化构建速度(可用于生产环境) <ul><li>优化 babel-loader</li><li>IgnorePlugin</li><li>noParse</li><li>happyPack</li><li>PrallelUglifyPlugin</li></ul></li><li>Webpack 优化构建速度(不可用于生产环境！) <ul><li>自动刷新</li><li>热更新</li><li>DllPlugin</li></ul></li></ul></li><li><p>优化产出代码 - 产品性能</p><blockquote><ul><li>体积更小</li><li>合理分包，不重复加载</li><li>速度更快、内存使用更小</li></ul></blockquote><ul><li>小图片 base64 编码</li><li>bundle加hash</li><li>懒加载</li><li>提取公共代码</li><li>IgnorePlugin</li><li>使用 CDN 加速，1.output设置publicPath cdn地址 2.将打包好的文件上传至cdn服务器上去。对于图片可以设置url-loader的publicPath</li><li>使用 production <ul><li>自动开启代码压缩</li><li>Vue React 等会自动删掉调试代码(如开发环境的 warning)</li><li>启用 tree-shaking（ES6 module 才能让 tree-shaking生效，commonjs不行） <ul><li>ES6 Module 和 Commonjs 区别 <ul><li>ES6 Module 静态引入，编译时引入</li><li>Commonjs 动态引入，执行时引入</li><li>只有静态引用才能实现 Tree-Shaking</li></ul></li></ul></li></ul></li><li>Scope Hosting <ul><li>代码体积更小</li><li>创建函数作用域更少</li><li>代码可读性更好</li></ul></li></ul></li></ul><p>优化 babel-loader</p><img src="'+r+'" alt="image-20231014191204868" style="zoom:25%;"><p>noParse 避免重复打包</p><img src="'+n+'" alt="image-20231014192644213" style="zoom:25%;"><p>自动刷新</p><img src="'+p+`" alt="image-20231014193856648" style="zoom:25%;"><p>Scope Hosting</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// hello.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello 双越&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./hello.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">conso.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str)</span></span></code></pre></div><p><img src="`+u+'" alt="image-20231015070459001"></p><p>两个文件对应两个函数，把两个函数合起来，所以当文件越多，代码体积越大，效果越好</p><p><img src="'+b+'" alt="image-20231015070615681"></p><p>scope hosting配置</p><p><img src="'+c+'" alt="image-20231015070836502"></p><h3 id="如何产出一个lib" tabindex="-1">如何产出一个lib <a class="header-anchor" href="#如何产出一个lib" aria-label="Permalink to &quot;如何产出一个lib&quot;">​</a></h3><ul><li>参考 webpack.dll.js</li><li>output.library</li></ul><img src="'+h+'" alt="image-20231015084534908" style="zoom:25%;"><h3 id="除了-webpack-的新打包工具" tabindex="-1">除了 webpack 的新打包工具 <a class="header-anchor" href="#除了-webpack-的新打包工具" aria-label="Permalink to &quot;除了 webpack 的新打包工具&quot;">​</a></h3><h3 id="webpack分包做了什么" tabindex="-1">webpack分包做了什么 <a class="header-anchor" href="#webpack分包做了什么" aria-label="Permalink to &quot;webpack分包做了什么&quot;">​</a></h3><h2 id="babel-面试题" tabindex="-1">babel 面试题 <a class="header-anchor" href="#babel-面试题" aria-label="Permalink to &quot;babel 面试题&quot;">​</a></h2><h3 id="babel-runtime-和-babel-polyfill-的区别" tabindex="-1">babel-runtime 和 babel-polyfill 的区别 <a class="header-anchor" href="#babel-runtime-和-babel-polyfill-的区别" aria-label="Permalink to &quot;babel-runtime 和 babel-polyfill 的区别&quot;">​</a></h3><ul><li>babel-polifll 会污染全局</li><li>babel-runtime 不会污染全局</li><li>产出第三方 lib 要用 babel-runtime</li></ul><h3 id="babel-和-webpack-的区别" tabindex="-1">babel 和 webpack 的区别 <a class="header-anchor" href="#babel-和-webpack-的区别" aria-label="Permalink to &quot;babel 和 webpack 的区别&quot;">​</a></h3><ul><li>babel - JS 新语法编译工具，不关心模块化</li><li>webpack - 打包构建工具，是多个 loader plugin的集合</li></ul><h3 id="为何-proxy-不能被-polyfill" tabindex="-1">为何 Proxy 不能被 Polyfill？ <a class="header-anchor" href="#为何-proxy-不能被-polyfill" aria-label="Permalink to &quot;为何 Proxy 不能被 Polyfill？&quot;">​</a></h3><ul><li>如 Class 可以用 function 模拟</li><li>如 Promise 可以用 callback 模拟</li><li>但 Proxy 的功能用 Object.defineProperty 无法模拟</li></ul><h2 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;vite&quot;">​</a></h2><h3 id="vite的优缺点" tabindex="-1">vite的优缺点 <a class="header-anchor" href="#vite的优缺点" aria-label="Permalink to &quot;vite的优缺点&quot;">​</a></h3><p><strong>缺点</strong></p><p>Vite 是一个现代化的前端构建工具，它在性能和开发体验方面具有许多优点。然而，它也存在一些潜在的缺点，包括：</p><ol><li><p>社区支持相对较新：相对于其他成熟的前端构建工具（如Webpack和Parcel），Vite 是一个较新的项目，因此其社区支持相对较小。这可能导致在使用过程中遇到的问题难以找到解决方案或相关文档。</p></li><li><p>生态系统相对较小：Vite 生态系统相对较小，与像Webpack这样的工具相比，可能缺乏一些插件和工具的支持。这可能需要你编写自定义的插件或处理一些特殊的需求。</p></li><li><p>配置复杂性：Vite 的配置相对简单，但在处理一些复杂场景时，可能需要更深入的配置。相对于其他工具，如Webpack，Vite 的配置选项相对有限，可能需要更多的自定义处理。</p></li><li><p>构建速度慢：尽管 Vite 在开发模式下具有快速的冷启动和热重载功能，但在生产模式下，Vite 的构建速度可能比一些其他工具慢。这对于大型项目或需要复杂构建过程的项目可能会产生一些影响。</p></li><li><p>兼容性问题：由于 Vite 采用了 ES 模块的方式进行模块解析，一些旧版本的浏览器可能不支持这种模块系统，需要进行额外的兼容性处理。这可能增加一些开发和配置的复杂性。</p></li></ol><p>需要注意的是，尽管 Vite 存在一些潜在的缺点，但它仍然是一个强大且受欢迎的前端构建工具，特别适用于现代化的前端项目。选择使用 Vite 还是其他工具应该根据具体项目需求和团队偏好进行评估。</p><p>优点</p><p>Vite 是一个现代化的前端构建工具，具有多个优点，包括：</p><ol><li><p>快速的冷启动：Vite 采用了基于 ES 模块的开发服务器，利用浏览器原生的 ES 模块解析功能，因此在开发模式下具有非常快速的冷启动速度。这意味着你可以更快地启动开发服务器并立即开始开发工作，无需长时间等待构建过程。</p></li><li><p>高性能的热模块替换：Vite 通过使用原生的模块系统，实现了高性能的热模块替换（HMR）。在开发过程中，当你修改代码时，Vite 可以实时更新只有修改的部分，而无需刷新整个页面。这提供了更快的开发反馈和更高效的开发体验。</p></li><li><p>简化的配置：相对于其他前端构建工具，如Webpack，Vite 的配置更加简化和直观。它采用了约定优于配置的原则，可以根据文件的类型和位置自动处理模块解析、代码转换和资源管理，减少了繁琐的配置过程。</p></li><li><p>内置的开箱即用功能：Vite 内置了对常见前端框架（如Vue、React、Angular）的支持，并提供了一些开箱即用的功能，如对单文件组件的原生支持、CSS 预处理器的集成、代码分割等。这使得你可以更快速地搭建和开发现代化的前端项目。</p></li><li><p>构建速度优化：Vite 在构建生产版本时，采用了预构建的方式，将依赖关系转换为高度优化的静态资源。这使得构建过程更加高效，生成的生产代码体积更小，加载速度更快。</p></li><li><p>模块化开发体验：Vite 鼓励使用原生的 ES 模块语法进行开发，使得模块化的开发和维护更加简单和清晰。你可以直接使用 npm 或 yarn 安装模块，无需进行额外的构建步骤或配置。</p></li></ol><p>综上所述，Vite 通过快速的冷启动、高性能的热模块替换、简化的配置和内置的开箱即用功能等特点，提供了更高效、更快速的前端开发体验。它适用于现代化的前端项目，并受到许多开发者的欢迎。</p>',84),g=[k];function m(P,f,w,y,q,_){return a(),i("div",null,g)}const E=l(d,[["render",m]]);export{S as __pageData,E as default};
