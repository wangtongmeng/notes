import{_ as a,c as i,o as l,a4 as e}from"./chunks/framework.C5rzuSi5.js";const m=JSON.parse('{"title":"js基础","description":"","frontmatter":{},"headers":[],"relativePath":"fe/javascript/js基础.md","filePath":"fe/javascript/js基础.md","lastUpdated":1697937582000}'),s={name:"fe/javascript/js基础.md"},t=e(`<h1 id="js基础" tabindex="-1">js基础 <a class="header-anchor" href="#js基础" aria-label="Permalink to &quot;js基础&quot;">​</a></h1><h2 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h2><ul><li>class和继承</li><li>类型判断 instanceof</li><li>原型和原型链</li></ul><h3 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h3><ul><li>constructor</li><li>属性</li><li>方法</li></ul><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3><ul><li>extends</li><li>super</li><li>扩展或重写方法</li></ul><h3 id="类型判断-instanceof" tabindex="-1">类型判断 instanceof <a class="header-anchor" href="#类型判断-instanceof" aria-label="Permalink to &quot;类型判断 instanceof&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Arrary</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span></code></pre></div><h2 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h2><h3 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h3><h3 id="async-await" tabindex="-1">async await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async await&quot;">​</a></h3><p>async和 Promise 的关系</p><ul><li>执行 aysnc 函数，返回的是Promise对象</li><li>await 相当于 Promise 的 then</li><li>try..catch 可捕获异常，代替了 Promise 的 catch</li></ul><h3 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h3><ul><li>宏任务：setTimeout、setInterval、ajax、DOM 事件</li><li>微任务：Promise async/await</li></ul><h3 id="event-loop过程" tabindex="-1">event loop过程 <a class="header-anchor" href="#event-loop过程" aria-label="Permalink to &quot;event loop过程&quot;">​</a></h3><ul><li>同步代码，一行一行放在 Call Stack 执行</li><li>遇到异步，会先“记录”下，等待时机（定时、网络请求等）</li><li>时机到了，就移动到 Callback Queue</li><li>如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作</li><li>轮询查找 Callback Queue，如有则移动到 Call Stack 执行</li><li>然后继续轮询查询（像永动机）</li></ul><h3 id="event-loop-和-dom-渲染" tabindex="-1">event loop 和 DOM 渲染 <a class="header-anchor" href="#event-loop-和-dom-渲染" aria-label="Permalink to &quot;event loop 和 DOM 渲染&quot;">​</a></h3><ul><li>JS 是单线程的，而且和 DOM 渲染共用一个线程</li><li>异步（setTimeout，ajax 等）使用回调，基于 event loop</li><li>DOM 事件也使用回调，基于 event loop</li><li>JS 执行时，得留一些时机工供 DOM 渲染</li><li>每次 Call Stack 清空(即每次轮询结束)，即同步任务执行完</li><li>都是 DOM 重新渲染的机会，DOM 结构如有改变则重新渲染</li><li>然后再触发下一次 Event Loop</li></ul>`,20),n=[t];function o(r,h,c,d,p,k){return l(),i("div",null,n)}const b=a(s,[["render",o]]);export{m as __pageData,b as default};
