  ## 项目工程规范化做了什么

在前端项目中，可以采用以下一些规范和最佳实践来提高工程的规范化和可维护性：

1. 代码风格规范：采用一致的代码风格可以增加代码的可读性和可维护性。可以使用工具如ESLint或Prettier来对代码进行静态检查和格式化。

2. 目录结构规范：定义清晰的目录结构可以方便团队成员理解项目的组织方式。可以按照功能模块、文件类型或者特定的业务需求进行组织。

3. 文件命名规范：使用有意义且一致的文件命名规范可以提高代码的可读性和可维护性。可以使用驼峰命名法、短横线命名法等。

4. 编码规范：制定一致的编码规范，包括变量命名、函数命名、注释规范等。这可以帮助团队成员理解和维护彼此的代码。

5. 代码注释规范：为代码添加清晰的注释可以提高代码的可读性和可维护性。注释应该解释代码的意图、算法、边界条件等关键信息。

6. 版本控制规范：使用版本控制系统（如Git）管理代码，并定义分支管理策略、提交规范等。这有助于团队在多人协作中保持代码的一致性和追踪变更历史。

7. 构建和打包规范：使用工具如Webpack或Parcel进行项目构建和打包时，可以定义一致的配置和规范，包括文件压缩、静态资源管理、代码分割等。

8. 测试规范：编写单元测试、集成测试和端到端测试，确保代码的质量和功能的正确性。使用工具如Jest、Mocha、Cypress等来进行测试。

9. 文档规范：编写项目文档，包括项目说明、技术文档、API文档等。这有助于团队成员理解项目的设计和实现细节。

10. 性能优化规范：遵循性能优化的最佳实践，包括减少网络请求、使用缓存、代码优化等，以提升应用的加载速度和响应性能。

以上是一些常见的前端项目工程规范化的方面，根据具体项目的需求和团队的偏好，还可以进一步制定和补充其他规范。

  ## webpack 工程优化做了哪些

  ## Mobx 状态管理与 Redux 有什么不同

  ## 单点登录 SP 发起登录的过程

  ## 浏览器 强缓存、协商缓存 都针对那些资源

  ## cookie 有哪些字段

  ## web 安全 xss csrf 细节

  ## 第三方授权认证 SDK 怎么发包，发什么样的包

当你准备将第三方授权认证 SDK 发布为一个包时，你需要进行以下步骤：

1. 初始化项目：创建一个新的项目目录，并在该目录下初始化一个新的 npm 包。可以通过运行 `npm init` 命令来初始化包，并按照提示填写相关信息，如包名、版本号、描述等。

2. 编写代码：在项目目录下编写你的第三方授权认证 SDK 的代码。根据你的需求和目标平台，可以使用不同的编程语言和框架来实现 SDK。确保你的代码符合规范，具有良好的可读性和可维护性。

3. 定义依赖：确定你的 SDK 依赖的第三方库和工具。在项目的根目录下创建一个 `package.json` 文件（如果 `npm init` 时没有自动生成），并在其中添加你的依赖项。可以使用 `npm install` 命令来安装这些依赖项。

4. 添加入口文件：在你的项目中添加一个入口文件，用于导出 SDK 的公共接口。这个文件将作为用户在其他项目中引入你的 SDK 时的入口点。

5. 测试：编写测试用例来验证你的 SDK 的功能和正确性。可以使用测试框架（如Jest、Mocha等）来编写和运行测试。

6. 文档：编写用户文档，包括 SDK 的安装说明、使用示例、API 文档等。这有助于其他开发者理解和使用你的 SDK。

7. 构建和打包：使用适当的工具（如Webpack、Babel等）对你的 SDK 代码进行构建和打包，以便在不同的环境中使用。

8. 发布包：将你的 SDK 发布到包管理器（如npm）上，以便其他人可以方便地安装和使用你的 SDK。使用 `npm publish` 命令将你的包发布到 npm 上，并确保你具有发布权限。

9. 版本控制：在发布新版本之前，确保你使用合适的版本控制系统（如Git）对你的代码进行管理，并按照语义化版本（Semantic Versioning）规范来管理版本号。

10. 更新和维护：持续更新和维护你的 SDK，修复 bug、添加新功能，并及时响应用户的反馈和需求。

以上是将第三方授权认证 SDK 发布为一个包的一般步骤。具体的实施方法和工具选择可能因你使用的编程语言和开发环境而有所不同。确保在发布包之前，仔细测试和审查你的代码，以确保其质量和安全性。

  ## 手写题 输出运行结果



  ```js
  for (var i=0;i<3;i++) {
    setTimeout(() => console.log('p', i));
    new Promise((resolve) => {
      console.log('q', i);
      resolve();
    }).then(() => {
      console.log('k', i);
    })
    console.log('f', i);
  }
  
  'q' 0
  'f' 0
  'q' 1
  'f' 1
  'q' 2
  'f' 2
  'k' 3 三次
  'p' 3 三次
  ```

  ## 手写题， 创建一个 函数 fn， 使其有如下输出值

  ```js
/**
 *26 start a1
31 start a2
37 start a3
39 end a3
33 end a2
28 end a1 
 * 
 * 
*/
  function a1(next) {
    console.log('start a1');
    next();
    console.log('end a1');
  }
  function a2(next) {
    console.log('start a2');
    next();
    console.log('end a2');
  }

  function a3(next) {
    console.log('start a3');
    next();
    console.log('end a3');
  }

  function fn(arr) {
    // ... 实现具体代码
    let res = arr.reduceRight((next, current) => {
      return () => {
        current(next);
      };
    }, () => {}); // 初始的 next 函数是一个空函数
		
    return res()
  }

  fn([a1, a2, a3]);
  ```