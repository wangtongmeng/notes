## 高阶函数
高阶函数的概念： 1.一个函数返回一个函数  2. 一个函数可以参数接受一个函数 高阶函数

这两个条件满足任何一个均可，promise内部肯定也是回调函数 （内部包含着高阶函数）

### before函数
扩展方法 会用到高阶函数 

```javascript
function core(...args) { // 核心代码
    console.log('core', args)
}
// 给core函数增加一些额外的逻辑 但是不能更改核心代码
Function.prototype.before = function (cb) {
    return (...args) => { // 剩余运算符 可以把多个参数转化成数组
        cb()
        this(...args) // 拓展运算符
    }
}
let newCore = core.before(()=>{
    console.log('before')
})

newCore('a', 'b')
```

### 柯理化函数
“函数柯里化”  多个参数的传入 把他转化成 n个函数   可以暂存变量

一般柯里化参数要求 都是一个个的传  => 偏函数

 柯里化： 让函数变得更具体一些，反柯里化： 让函数范围变的更大一些



实现通用的柯里化函数： 高阶函数

```javascript
function curring(fn) {
  const inner = (args = []) => { // 存储每次调用时传入的参数
    return args.length >= fn.length? fn(...args): (...userArgs) => inner([...args, ...userArgs]) // 递归返回函数
  }
  return inner()
}
```

sum求和

```javascript
function sum(a,b,c,d) {
  return a+b+c+d
}
let sum1 = curring(sum)
let sum2 = sum1(1)
let sum3 = sum2(2,3)
let result = sum3(4)
console.log(result) // 10
```

类型判断

判断一个变量的类型  （代码的实现 类型是基本条件）

typeof 我们一般用于判断基础类型

instanceof xxx是谁的实例 原理

Object.prototype.toString.call  判断具体类型 返回的是一个字符串

coustructor 深拷贝会用到

```javascript
// 不使用柯理化
function isString(typing) {
  return function (val) {
    return Object.prototype.toString.call(val) == `[object ${typing}]`
  }
}
function isNumber(typing) {
  return function (val) {
    return Object.prototype.toString.call(val) == `[object ${typing}]`
  }
}
let myIsString = isString('String')
console.log(myIsString(123)) // false
console.log(myIsString('123')) // true

// 使用柯理化
function isType(typing,val) {
  return Object.prototype.toString.call(val) == `[object ${typing}]`
}
let util = {}
let arr = ['String','Number','Boolean','Null','Undefined']
arr.forEach(type => {
  util['is'+type] = curring(isType)(type)
});


console.log(util.isString(123)) // false
console.log(util.isNumber(123)) // true
```

柯理化应用场景

+ 请求数据 多个接口等待数据返回后 再去渲染页面
+ 类型判断

### after函数
解决请求并发问题



不使用after函数

根目录下新建 a.txt (内容b.txt) b.txt(b)

```javascript
const fs = require('fs')


let arr = []
function out(data) { // 不关心顺序
    arr.push(data)
    if (arr.length == 2) {
        // ...
        console.log(arr) // [ 'b.txt', 'b' ]
    }
}
fs.readFile('./a.txt', 'UTF8', function (err,data) {
    out(data)
})
fs.readFile('./b.txt', 'UTF8', function (err,data) {
    out(data)
})
```

使用after函数

```javascript
const fs = require('fs')

function after(times, callback) {
    let arr = []
    return (data,index)=>{
        arr[index] = data // 保存顺序 采用索引
        if(--times === 0) { // 多个请求并发 需要靠计数器来实现
            callback(arr)
        }
    }
}
let out = after(2, arr => {
    // ...
    console.log(arr) // [ 'b.txt', 'b' ]
})
fs.readFile('./a.txt', 'UTF8', function (err,data) {
    out(data, 0)
})
fs.readFile('./b.txt', 'UTF8', function (err,data) {
    out(data, 1)
})
```

### 发布订阅模式、观察者模式
**发布订阅模式**

核心就是把多个方法先暂存起来，最后一次执行

解耦合

```javascript
const fs = require('fs')

let events = {
    _events: [],
    on(fn) {
        this._events.push(fn)
    },
    emit(data) {
        this._events.forEach(fn => fn(data))
    }
}

fs.readFile('./a.txt','UTF8',function (err,data) {
    events.emit(data);
})
fs.readFile('./b.txt','UTF8',function (err,data) {
    events.emit(data);
})

let arr = []
events.on(data => {
    arr.push(JSON.stringify(data))
})
events.on(()=>{
    if (arr.length === 2) { // 本质还是通过计数器
        console.log('读取完毕', arr) // [ '"b.txt"', '"b"' ]
    }
})
```

观察者模式 vue2  基于发布订阅的  (发布订阅之间是没有依赖关系的)

对于我们的观察者模式 观察者  被观察者  vue3 中没有使用class

**观察者模式**

观察者模式基于发布订阅模式，被观察者需要收集观察者

vue 数据变了（状态） 视图要更新 （通知依赖的人） 

```javascript

class Subject { // 被观察者 需要将观察者收集起来
    constructor(name){
        this.name = name
        this.state = '非常开心'
        this.observers = []
    }
    attach(o){ // 收集观察者
        this.observers.push(o) // on
    }
    setState(newState){
        this.state = newState
        this.observers.forEach(o => o.update(this.name, newState)) // emit
    }
}
class Observer { // 观察者
    constructor(name){
        this.name = name
    }
    update(s,state){
        console.log(this.name+':'+s+'当前'+state)
    }
}

let s = new Subject('小宝宝')
let o1 = new Observer('爸爸')
let o2 = new Observer('妈妈')

s.attach(o1)
s.attach(o2)
s.setState('不开心了')
s.setState('开心')
```

## promise使用及原理
promise 解决了什么问题 1.链式调用解决嵌套回调的问题 和 2.同步并发问题 3. 多个异步处理错误问题

### 基本的promise
promise 还是基于回调的 es6-promise  

1.promise是一个类 ，无需考虑兼容性

2.当使用promise的时候 会传入一个执行器，此执行器是立即执行

3.当前executor 给了两个函数可以来描述当前promise的状态。promise中有三个状态 成功态  失败态 等待态

默认为等待态  如果调用resolve会走到成功态，如果调用reject 或者发生异常 会走失败态

4.每个promise实例都有一个then方法

5.promise 一旦状态变化后不能更改

```javascript
let Promise = requrie('./source/1.promise.js')

let p = new Promise((resolve, reject) => {
    console.log('promise')
    // resolve('value')
    // reject('reason')
    throw new Error('失败了')
})
p.then(value => {
    console.log('success', value)
}, reason => {
    console.log('err', reason)
})


// /source/1.promise.js
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';
class Promise {
    constructor(executor) {
        this.status = PENDING; // promise默认的状态
        this.value = undefined; // 成功的原因
        this.reason = undefined; // 失败的原因
        const resolve = (value) => { // 成功resolve函数
            if (this.status === PENDING) {
                this.value = value;
                this.status = FULFILLED; // 修改状态
            }
        }
        const reject = (reason) => { // 失败的reject函数
            if (this.status === PENDING) {
                this.reason = reason;
                this.status = REJECTED // 修改状态
            }
        }
        try {
            executor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }
    then(onFulfilled, onRejected) { // onFulfilled, onRejected
        if (this.status == FULFILLED) { // 成功调用成功方法
            onFulfilled(this.value);
        }
        if (this.status === REJECTED) { // 失败调用失败方法
            onRejected(this.reason);
        }
    }
}

module.exports = Promise
```

### 异步问题
当用户调用then方法的时候 此时promise可能为等待态， 先暂存起来，因为后续可能会调用resolve和reject， 等会再触发对应onFulfilled 或者 onRejected =>发布订阅模式

```javascript
let Promise = require('./source/2.promise')

let p = new Promise((resolve, reject) => {  // pending
    setTimeout(() => {
        resolve('ok')
    }, 1000);
})

// 当用户调用then方法的时候 此时promise可能为等待态， 先暂存起来，因为后续可能会调用resolve和reject， 等会再触发对应onFulfilled 或者 onRejected
p.then(value => { // then是异步的
    console.log('success1', value)
}, reason => {
    console.log('err', reason)
})
p.then(value => { // then是异步的
    console.log('success2', value)
}, reason => {
    console.log('err', reason)
})


// ./source/2.promise
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';
class Promise {
    constructor(executor) {
        this.status = PENDING;
        this.value = undefined;
        this.reason = undefined;
        this.onResolvedCallbacks = [] // 存放成功的回调方法
        this.onRejectedCallbacks = [] // 存放失败的回调方法
        const resolve = (value) => {
            if (this.status === PENDING) {
                this.value = value;
                this.status = FULFILLED;
                // 发布
                this.onResolvedCallbacks.forEach(fn=>fn())
            }
        }
        const reject = (reason) => {
            if (this.status === PENDING) {
                this.reason = reason;
                this.status = REJECTED
                this.onRejectedCallbacks.forEach(fn=>fn())
            }
        }
        try {
            executor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }
    then(onFulfilled, onRejected) { // onFulfilled, onRejected
        // 订阅模式
        if (this.status === PENDING) { // 代码是异步调用resolve或reject的
            this.onResolvedCallbacks.push(() => { // 切片变成 AOP
                // todo...
                onFulfilled(this.value)
            })
            this.onRejectedCallbacks.push(()=>{
                onRejected(this.reason)
            })
        }
        if (this.status == FULFILLED) {
            onFulfilled(this.value);
        }
        if (this.status === REJECTED) {
            onRejected(this.reason);
        }
    }
}

module.exports = Promise
```

### 链式调用及其他
1.链式调用

2.then 返回的不能是本身

3.避免直接 x.then

4.递归解析promise

5.值的穿透 .then().then().then()

6.一个promise直接resolve一个promise的情况

7.promise延迟对象的使用

8.promise a+ 测试

#### 1.链式调用
promise的链式调用解决嵌套回调的问题， 当调用then方法后会返回一个新的promise

情况1： then中方法返回的是一个（普通值 不是promise）的情况, 会作为外层下一次then的成功结果

情况2： then中方法 执行出错 会走到外层下一次then的失败结果

情况3： 如果then中方法返回的是一个promise对象， 此时会根据promise的结果来处理是走成功还是失败 （传入的是成功或者失败的内容）

无论上一次then走是成功还是失败，只要返回的是普通值 都会执行下一次then的成功

总结： 如果返回一个普通值 （除了promise） 就会传递给下一个then的成功，如果返回一个失败的promise或者抛出异常，会走下一个then的失败

```javascript
const fs = require('fs')
let p = new Promise((resolve,reject)=>{
    resolve(1)
}).then(data=> {
    return new Promise((resolve,reject)=>{ // x 可能是一个promise
        setTimeout(() => {
            resolve('ok')
        }, 1000);
    })
}, err => {
    return 111
})

p.then(data => {
    console.log(data) //一秒后 ok
}, err => {
    console.log('error', err)
})

const fs = require('fs')
function readFile(filePath,encoding) {
    return new Promise((resolve, reject)=>{
        fs.readFile(filePath,encoding, (err,data)=>{ // nodeApi 转化成promise
            if (err) return reject(err)
            resolve(data)
        })
    })
}

// readFile('./a.txt1', 'utf8').then(value=>{
readFile('./a.txt', 'utf8').then(value=>{
    return readFile(value, 'utf8')
    // return readFile(value+'1', 'utf8')
},err=>{
    return new Error() // 这里返回一个错误对象，不是抛出错误，所有走下一个then的成功回调
})
.then(data => {
    console.log('success', data)
}, () => {
    console.log('fail')
})
```

#### 2.then 返回的不能是本身
```javascript
// promise2 === x的情况
const Promise = require('./source/3.promise')

let promise2 = new Promise((resolve,reject)=> {
    resolve(1)
}).then(() => {
    return promise2 // x
})

promise2.then(data => {
    console.log(data)
}, err => {
    console.log(err)
})
```

#### 3.避免直接 x.then
```javascript
let p = {}
let index = 0;
Object.defineProperty(p,'then',{
    get(){
        if(++index == 2)  throw new Error() 
      ;
    }
})
```

#### 4.递归解析promise
```javascript
let promise2 = new Promise((resolve)=>{
    resolve(1);
}).then(data=>{
    return new Promise((resolve,reject)=>{ // x 可能是一个promise
        setTimeout(() => {
            resolve(new Promise((resolve,reject)=>{
                setTimeout(() => {
                    resolve('200');
                }, 1000);
            }))
        }, 1000);
    })
},(err)=>{
    return 111
})
promise2.then(data=>{
    console.log(data) // 3秒后打印 200
},err=>{
    console.log('error',err)
});
```

#### 5.值的穿透 .then().then().then()
```javascript
new Promise((resolve, reject) => {
    reject(200)
}).then(null).then((data) => {
    console.log(data, 's')
}, err => {
    console.log(err, 'e') // 200 e
})
```

#### 6.一个promise直接resolve一个promise的情况
```javascript
new Promise((resolve, reject) => {
    // reject(new Promise((resolve, reject) => {
    //    setTimeout(() => {
    //     resolve(100)
    //    }, 1000);
    // }))
    resolve(new Promise((resolve, reject) => {
        setTimeout(() => {
         resolve(100)
        }, 1000);
     }))
}).then(data=>{
    console.log(data); // 1s后打印 100
},err=>{
    console.log(err,'err');
})
```

#### 7.promise延迟对象的使用
```javascript
function readFile(filePath, encoding) {
    let dfd = Promise.deferred();
    fs.readFile(filePath, encoding, (err, data) => { // nodeApi 转化成promise
        if (err) return dfd.reject(err);
        dfd.resolve(data);
    })
    return dfd.promise;
}

readFile('./a.txt', 'utf8').then((data => {
    console.log(data)
}))
```

#### 8.promise代码
```javascript
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';


// 利用x的值来判断是调用promise2的resolve还是reject
function resolvePromise(promise2, x, resolve, reject) {
    if (promise2 === x) { // 2.then返回的不能是本身
        return reject(new TypeError('错误'))
    }
    if ((typeof x === 'object' && x !== null) || typeof x === 'function') { 
        let called = false;
        try {
            let then = x.then; // 3.避免直接x.then
            if (typeof then === 'function') {
                then.call(x, y => {
                    if (called) return;
                    called = true;
                    resolvePromise(promise2, y, resolve, reject); // 4.递归解析promise
                }, r => { // reason
                    if (called) return;
                    called = true;
                    reject(r);
                });
            } else { // {}  {then:{}}
                resolve(x);
            }
        } catch (e) {
            if (called) return;
            called = true;
            reject(e);
        }
    } else {
        resolve(x);
    }
}

class Promise {
    constructor(executor) {
        this.status = PENDING; 
        this.value = undefined;
        this.reason = undefined; 
        this.onResolvedCallbacks = []; // 存放成功的回调方法
        this.onRejectedCallbacks = []; // 存放失败的回调方法
        const resolve = (value) => { // 成功resolve函数
            if(value instanceof Promise){ // 6.一个promise直接resolve一个promise的情况
                return value.then(resolve,reject)
            }
            if (this.status === PENDING) {
                this.value = value;
                this.status = FULFILLED; // 修改状态
                // 发布
                this.onResolvedCallbacks.forEach(fn => fn());
            }
        }
        const reject = (reason) => { // 失败的reject函数
            if (this.status === PENDING) {
                this.reason = reason;
                this.status = REJECTED // 修改状态
                this.onRejectedCallbacks.forEach(fn => fn());
            }
        }
        try {
            executor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }
    then(onFulfilled, onRejected) { // onFulfilled, onRejected
      	// 5.值的穿透
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
        onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err; }
        let promise2 = new Promise((resolve, reject) => { // 1.链式调用
            if (this.status == FULFILLED) {
                setTimeout(() => {
                    try {
                        let x = onFulfilled(this.value);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }, 0);
            }
            if (this.status === REJECTED) {
                setTimeout(() => {
                    try {
                        let x = onRejected(this.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }, 0);

            }
            if (this.status == PENDING) {
                this.onResolvedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            // todo...
                            let x = onFulfilled(this.value);
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);

                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            // todo...
                            let x = onRejected(this.reason);
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);
                });
            }
        })
        return promise2
    }
}
Promise.deferred = function () { // promise延迟对象
    let dfd = {};
    dfd.promise = new Promise((resolve,reject)=>{
        dfd.resolve= resolve;
        dfd.reject = reject;
    }); 
    return dfd;
}
module.exports = Promise
```

#### 9.promise a+ 测试
```shell
https://promisesaplus.com/
https://github.com/promises-aplus/promises-tests

npm install promises-aplus-tests -g
promises-aplus-tests
```

### 静态方法及原型方法
#### 1.Promise.resolve()
```javascript
Promise.resolve(value) {
  return new Promise((resolve, reject) => {
    resolve(value)
  })
}

// 1.Promise.resolve() 这个方法  会创造一个成功的promise
Promise.resolve(1).then(value => {
    console.log(value)
})
Promise.resolve(new Promise((resolve,reject) => {
    setTimeout(() => {
        // resolve(1)
        reject(1)
    }, 1000);
})).then(value => {
    console.log('success', value)
}).catch(err => {
    console.log('err', err)
})
```

#### 2.Promise.reject()
```javascript
Promise.reject(value) {
  return new Promise((resolve, reject) => {
    reject(value)
  })
}

// 2.Promise.reject() 这个方法  会创造一个失败的promise
Promise.reject(1).then((data) => {
    console.log(data)
}).catch(err => { // catch方法就是没有成功的失败
    console.log(err, 'err')
});

Promise.reject(new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(200);
    }, 1000);
})).then((data) => {
    console.log(data)
}).catch(err => { // catch方法就是没有成功的失败
    console.log(err, 'err')
});
```

#### 3.Promise.all()
```javascript
Promise.all(promises) { // 非 promise a+ Promise.all
  return new Promise((resolve, reject) => {
    let result = []
    let times = 0
    const processSuccess = (index, val) => {
      result[index] = val
      if (++times === promises.length) {
        resolve(result)
      }
    }

    for (let i = 0; i < promises.length; i++) { // 并发 多个请求一起执行
      let p = promises[i]
      if (p && typeof p.then === 'function') {
        p.then(data => {
          processSuccess(i, data)
        }, reject) // 如果其中某一个promise失败了 直接执行失败即可
      } else {
        processSuccess(i, p)
      }
    }
  })
}

// 3.Promise.all 并发请求 全部成功才成功，一个失败则失败
// 多个promise全部完成后获取结果，但是其中的某个如果失败了 那么这个promise就失败了
// 同步（同一时刻拿到） 多个异步请求的结果
let p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功')
    }, 2000);
})
let p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功')
    }, 1000);
})
Promise.all([p1, p2, 1, 2, 3]).then(data => {
    console.log(data)
}).catch(err => {
    console.log('err', err)
})
```

#### 4.Promise.race()
```javascript
Promise.race(promises) { // 非 promise a+ Promise.race
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      let p = promises[i]
      if (p && typeof p.then === 'function') {
        p.then(resolve, reject) // 一旦成功就直接 停止
      } else {
        resolve(p)
      }
    }
  })
}

// 4.Promise.race 有一个成功或失败就采用他的结果  应用：超时处理
// 赛跑 采用最快的那一个  race 方法如果其中一个完成了 其他的还是会执行的，并没有采用他的结果
let p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功')
    }, 500);
})
let p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败')
    }, 1000);
})

Promise.race([p1,p2]).then(data => {
    console.log(data)
}).catch(err => {
    console.log(err)
})

// 图片加载 请求的加载  造成超时（不采用成功的结果了）
// var abort
// let p1 = new Promise((resolve, reject) => {
//     abort = reject
//     setTimeout(() => {
//         resolve('成功')
//     }, 3000);
// })
// p1.abort = abort
// setTimeout(() => {
//     p1.abort()
// }, 2000);
// 构造一个自己的promise和 p1 放在一起，暴露一个中断方法
function wrap(p1) { // 图片加载失败问题 ， 脚本加载超时问题 
    let abort
    let p = new Promise((resolve, reject) => {
        abort = reject //  这是自己构造的promise，暴露一个中断方法
    })
    let p2 = Promise.race(p, p1)
    p2.abort = abort // 如果用户调用abort方法 这个p就失败了 = p2 就失败了
    return p2
}
let p2 = wrap(p1)
p2.then(data => {
    console.log(data)
}, err => {
    console.log(err)
})
setTimeout(() => {
    p2.abort('超时')
}, 2000);
```



#### 5.Promise.allSettled()
```javascript
Promise.allSettled(promises) {
  return new Promise((resolve, reject) => {
    let results = []
    let times = 0
    const process = (index, val, status) => {
      if (status === 'fulfilled') {
        results[index] = {
          status,
          value: val
        }
      }
      if (status === 'rejected') {
        results[index] = {
          status,
          reason: val
        }
      }
      if (++times === promises.length) {
        resolve(results)
      }
    }

    for (let i = 0; i < promises.length; i++) {
      let p = promises[i]
      if (p && typeof p.then === 'function') {
        p.then(data => {
          process(i, data, 'fulfilled')
        }, err => {
          process(i, err, 'rejected')
        })
      } else {
        process(i, p, 'fulfilled')
      }
    }
  })
}

// 5. Promise.allSettled([p1,p2])   但是会获得所有的结果， 不会走catch方法
let p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功')
    }, 1000);
})
let p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败')
    }, 500);
})
Promise.allSettled([p1,2,p2]).then(data => {
    console.log(data)
})
```

#### 6.Promise.any()
```javascript
Promise.any(promises) {
  return new Promise((resolve, reject) => {
    let result = []
    let times = 0
    const processFail = (index, val) => {
      result[index] = val
      if (++times === promises.length) {
        console.log(11, result)
        reject('AggregateError: All promises were rejected')
      }
    }

    for (let i = 0; i < promises.length; i++) {
      let p = promises[i]
      if (p && typeof p.then === 'function') {
        p.then(resolve, err => {
          processFail(i, err)
        })
      } else {
        resolve(p)
      }
    }
  })
}

// 6.Promise.any([p1,p2])  如果其中一个成功了 就会走成功 取出的是第一个成功的值， 都失败了 才会走失败
let p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        // resolve('成功')
        reject('失败1')
    }, 1000);
})
let p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败2')
    }, 500);
})
Promise.any([p1,p2]).then(data => {
    console.log(data)
}).catch(err => {
    console.log(err)
})
```

#### 7.Promise.prototype.catch()
```javascript
Promise.prototype.catch = function (errorFn) { // 非 promise a+ Promise.prototype.catch
        return this.then(null, errorFn)
    }
```

#### 8.Promise.prototype.finally()
```javascript
Promise.protoype.finally = function (cb) { // 非 promise a+ Promise.prototype.finally
  return this.then(data => {
    return Promise.resolve(cb()).then(() => data)
  }, err => {
    return Promise.resolve(cb()).then(() => {
      throw err
    })
  })
}

// Promise.prototype.finally 无论如何都会执行，但是可以继续向下执行


let p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        // resolve('成功')
        reject('失败')
    }, 3000);
}).finally(() => { // = then  无论状态如何都会执行
    console.log('finally') // 3s
    return new Promise((resolve, reject) => { // 不会使用promise的成功结果
        setTimeout(() => {
            resolve(1000)
        }, 1000);
    })
}).then(data => {
    console.log(data) // 成功  4s
}).catch(e => {
    console.log('catch', e) // 失败 4s
})
```

### 完整的promise
```javascript
// promise 还是基于回调的 es6-promise 
// 1.promise是一个类 ，无需考虑兼容性
// 2.当使用promise的时候 会传入一个执行器，此执行器是立即执行
// 3.当前executor 给了两个函数可以来描述当前promise的状态。promise中有三个状态 成功态  失败态 等待态
// 默认为等待态  如果调用resolve会走到成功态，如果调用reject 或者发生异常 会走失败态
// 4.每个promise实例都有一个then方法
// 5.promise 一旦状态变化后不能更改

const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

// 利用x的值来判断是调用promise2的resolve还是reject
function resolvePromise(promise2, x, resolve, reject) {
    // 核心流程
    if (promise2 === x) {
        return reject(new TypeError('错误'))
    }
    // 我可能写的promise 要和别人的promise兼容，考虑不是自己写的promise情况
    if ((typeof x === 'object' && x !== null) || typeof x === 'function') { // 有可能是promise 
        // 别人的promise可能调用成功后 还能调用失败~~~  确保了别人promise符合规范
        let called = false
        try { // 有可能then方法是通过defineProperty来实现的 取值时可能会发生异常
            let then = x.then
            if (typeof then === 'function') {
                // 这里我就认为你是promise了  x.then 这样写会触发getter可能会发生异常  
                then.call(x, y => {
                    if (called) return;
                    called = true;
                    resolvePromise(promise2, y, resolve, reject) // 直到解析他不是promise为止
                }, r => { // reason
                    if (called) return;
                    called = true;
                    reject(r)
                })
            } else { // {}  {then:{}}
                resolve(x) // 常量
            }
        } catch (e) {
            if (called) return;
            called = true;
            reject(e)
        }
    } else {
        resolve(x) // 说明返回的是一个普通值 直接将他放到promise2.resolve中
    }
}

class Promise {
    constructor(executor) {
        this.status = PENDING; // promise默认的状态
        this.value = undefined; // 成功的原因
        this.reason = undefined; // 失败的原因
        this.onResolvedCallbacks = [] // 存放成功的回调方法
        this.onRejectedCallbacks = [] // 存放失败的回调方法
        const resolve = (value) => { // 成功resolve函数
            if (value instanceof Promise) { // 一个promise直接resolve一个promise的情况
                return value.then(resolve, reject)
            }
            if (this.status === PENDING) {
                this.value = value;
                this.status = FULFILLED; // 修改状态
                // 发布
                this.onResolvedCallbacks.forEach(fn => fn())
            }
        }
        const reject = (reason) => { // 失败的reject函数
            if (this.status === PENDING) {
                this.reason = reason;
                this.status = REJECTED // 修改状态
                this.onRejectedCallbacks.forEach(fn => fn())
            }
        }
        try {
            executor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }
    // then中的参数是可选的 值的穿透
    then(onFulfilled, onRejected) { // onFulfilled, onRejected
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
        onRejected = typeof onRejected === 'function' ? onRejected : err => {
            throw err;
        }
        // 用于实现链式调用
        let promise2 = new Promise((resolve, reject) => {
            // 订阅模式
            if (this.status === PENDING) { // 代码是异步调用resolve或reject的
                this.onResolvedCallbacks.push(() => { // 切片变成 AOP
                    setTimeout(() => {
                        try {
                            // todo...
                            let x = onFulfilled(this.value)
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }
                    }, 0);
                })
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            let x = onRejected(this.reason)
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }
                    }, 0);
                })
            }
            if (this.status == FULFILLED) { // 成功调用成功方法
                setTimeout(() => {
                    try {
                        let x = onFulfilled(this.value);
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }
                }, 0);
            }
            if (this.status === REJECTED) { // 失败调用失败方法
                setTimeout(() => {
                    try {
                        let x = onRejected(this.reason);
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }
                }, 0);
            }
        })
        return promise2
    }
    static resolve(value) {
        return new Promise((resolve, reject) => {
            resolve(value)
        })
    }
    static reject(value) {
        return new Promise((resolve, reject) => {
            reject(value)
        })
    }
    catch (errorFn) { // 非 promise a+ Promise.prototype.catch
        return this.then(null, errorFn)
    }
    static all(promises) { // 非 promise a+ Promise.all
        return new Promise((resolve, reject) => {
            let result = []
            let times = 0
            const processSuccess = (index, val) => {
                result[index] = val
                if (++times === promises.length) {
                    resolve(result)
                }
            }

            for (let i = 0; i < promises.length; i++) { // 并发 多个请求一起执行
                let p = promises[i]
                if (p && typeof p.then === 'function') {
                    p.then(data => {
                        processSuccess(i, data)
                    }, reject) // 如果其中某一个promise失败了 直接执行失败即可
                } else {
                    processSuccess(i, p)
                }
            }
        })
    }
    static any(promises) {
        return new Promise((resolve, reject) => {
            let result = []
            let times = 0
            const processFail = (index, val) => {
                result[index] = val
                if (++times === promises.length) {
                    console.log(11, result)
                    reject('AggregateError: All promises were rejected')
                }
            }

            for (let i = 0; i < promises.length; i++) {
                let p = promises[i]
                if (p && typeof p.then === 'function') {
                    p.then(resolve, err => {
                        processFail(i, err)
                    })
                } else {
                    resolve(p)
                }
            }
        })
    }
    static race(promises) { // 非 promise a+ Promise.race
        return new Promise((resolve, reject) => {
            for (let i = 0; i < promises.length; i++) {
                let p = promises[i]
                if (p && typeof p.then === 'function') {
                    p.then(resolve, reject) // 一旦成功就直接 停止
                } else {
                    resolve(p)
                }
            }
        })
    }
    static allSettled(promises) {
        return new Promise((resolve, reject) => {
            let results = []
            let times = 0
            const process = (index, val, status) => {
                if (status === 'fulfilled') {
                    results[index] = {
                        status,
                        value: val
                    }
                }
                if (status === 'rejected') {
                    results[index] = {
                        status,
                        reason: val
                    }
                }
                if (++times === promises.length) {
                    resolve(results)
                }
            }

            for (let i = 0; i < promises.length; i++) {
                let p = promises[i]
                if (p && typeof p.then === 'function') {
                    p.then(data => {
                        process(i, data, 'fulfilled')
                    }, err => {
                        process(i, err, 'rejected')
                    })
                } else {
                    process(i, p, 'fulfilled')
                }
            }
        })
    }
    finally(cb) { // 非 promise a+ Promise.prototype.finally
        return this.then(data => {
            return Promise.resolve(cb()).then(() => data)
        }, err => {
            return Promise.resolve(cb()).then(() => {
                throw err
            })
        })
    }
}


// npm install promises-aplus-tests -g 
// 测试 promises-aplus-tests 此文件路径

// 延迟对象 帮我们减少一次套用 ： 针对目前来说 应用不是很广泛
Promise.deferred = function () {
    let dfd = {};
    dfd.promise = new Promise((resolve, reject) => {
        dfd.resolve = resolve;
        dfd.reject = reject;
    });
    return dfd;
}

module.exports = Promise
```

### promisify
promisify 主要的功能是将一个异步的方法转化成promise的形式  主要是给node来使用的

 回调函数的参数 永远第一个是error  error-first



将单个方法promise化

```javascript
const fs = require('fs')

function promisify(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (err, data) => {
                if (err) return reject(err)
                resolve(data)
            })
        })
    }
}

let readFile = promisify(fs.readFile)
readFile('./a.txt', 'utf8').then(data => console.log(data))
```

将node模块promise化

```javascript
function promisifyAll(obj) {
    let o = {}
    for(let key in obj) {
        if (typeof obj[key] === 'function') {
            o[key + 'Promise'] = promisify(obj[key])
        }
    }
    return o
}

let newFs = promisifyAll(fs)
newFs.readFilePromise('./a.txt', 'utf8').then(data => console.log(data))
```

## generator使用
```javascript
function * read() { // 生成器 他执行的结果叫迭代器
    var a = yield 1
    console.log(a) // b
    var b = yield 2
    console.log(b) // c
    var c = yield 3
    console.log(c) // d
}
let it = read()

var obj = it.next('a') // next的入参会给上一个yield的返回值，所以第一个next传参是没有意义的
console.log(obj); // { value: 1, done: false } 这里的value: 1 是 yield后表达式(promise，不是也会包装成promise)的结果
var obj = it.next('b')
console.log(obj); // { value: 2, done: false }
var obj = it.next('c')
console.log(obj); // { value: 3, done: false }
var obj = it.next('d')
console.log(obj); // { value: undefined, done: true }
```

核心靠的就是switch case 来实现的

经过babel转义，成es5代码，核心靠的就是switch case 来实现的

> [https://www.babeljs.cn/rep](https://www.babeljs.cn/rep) targets 填上 ie11
>

```javascript
// 自己补充
let  regeneratorRuntime = {
    mark(genFn){
        return genFn
    },
    wrap(iteratorFn){
        const context = {
            next:0,
            done:false, // 表示迭代器没有完成
            stop(){
                this.done = true
            }
        }
        let it ={ };
        it.next = function (v) { // 用户调用的next方法
           context.sent = v
           let value = iteratorFn(context);
           return {
               value,
               done:context.done // 是否完成
           }
        }
        return it;
    }
}
// 自己补充

// babel转义
"use strict";

var _marked = /*#__PURE__*/regeneratorRuntime.mark(read);

function read() {
  var a, b, c;
  return regeneratorRuntime.wrap(function read$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return 1;

        case 2:
          a = _context.sent;
          console.log(a); // b

          _context.next = 6;
          return 2;

        case 6:
          b = _context.sent;
          console.log(b); // c

          _context.next = 10;
          return 3;

        case 10:
          c = _context.sent;
          console.log(c); // d

        case 12:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var it = read();
var obj = it.next('a'); // next的入参会给上一个yield的返回值，所以第一个next传参是没有意义的

console.log(obj); // { value: 1, done: false } 这里的value: 1 是 yield后表达式(promise，不是也会包装成promise)的结果

var obj = it.next('b');
console.log(obj); // { value: 2, done: false }

var obj = it.next('c');
console.log(obj); // { value: 3, done: false }

var obj = it.next('d');
console.log(obj); // { value: undefined, done: true }
```

## co库原理
期望yield的返回值就是yield后表达式的结果

```javascript
function* read() { // 生成器 他执行的结果叫迭代器
    var a = yield 1;
    console.log(a);
    var b = yield 2;
    console.log(b);
    var c = yield 3;
    console.log(c);
}
let it = read();
let value,done;
do{
    let {value:v,done:d} = it.next(value);
    value = v;
    done = d;
}while(!done)
// 1 2 3
```

co库实现

```javascript
const util = require('util')
const fs = require('fs')
let readFile = util.promisify(fs.readFile)
// TJ co
// const co = require('co');
function co(it) { // 接收一个迭代器
    return new Promise((resolve, reject) => { // 返回一个promise
        // 异步的迭代  只能用递归的方法
        function next(data) {
            let { value, done } = it.next(data);
            if (done) { // 如果执行完毕则 完成
                resolve(value);
            } else {
                // 原生的promise 有优化 如果是promise 内部会直接把promise返回
                Promise.resolve(value).then(next, reject)
            }
        }
        next();
    })
}

function* read() {
    let data = yield readFile('./a.txt', 'utf8')
    data = yield readFile(data, 'utf8')
    return data
}
co(read()).then(data => {
    console.log(data); // b.txt
}).catch(err => {
    console.log(err);
})
```

generator + co 让代码看起来更像同步

## async await
async await 就是 generator + co 的语法糖

+ async函数返回的是promise

```javascript
const util = require('util')
const fs = require('fs')
let readFile = util.promisify(fs.readFile)

async function read() {
    let data = await readFile('./a.txt', 'utf8');
    data = await readFile(data, 'utf8');
    let r = await 1000
    return r;
}

read().then(data=>{
    console.log(data); // 1000
})
```

## 浏览器事件环
### 浏览器的进程
浏览器是多进程模型

+ 每一个页卡都是进程 (互不影响)
+ 浏览器也有一个主进程 (用户界面)
+ 渲染进程 每个页卡里 都有一个渲染进程 (浏览器内核)
+ 网络进程 （处理请求）
+ GPU进程 3d绘制
+ 第三方插件的进程

### 渲染进程（包含着多个线程）
+ GUI渲染线程 （渲染页面的）
+ js引擎线程 他和页面渲染时互斥 =>** js引擎和UI渲染共有一个线程**
+ 事件触发线程 独立的线程 EventLoop
+ 事件 click、setTimeout、ajax也是一个独立线程

被维护

> 微任务队列每次都会创建一个全新的队列、事件队列仅有一个
>

+ 事件队列、消息队列：存放定时器到达时间的回调函数、ajax回调成功的函数等
+ 事件循环：不断检测调用栈是否为空，如果为空则从事件对列中取出一个来执行

### 宏任务,微任务
+ 宏任务script ui 渲染、setTimeout、setInterval、postMessage、MessageChannel、SetImmediate
+ 微任务promise mutationObserver、process.nextTick

> 每循环一次会执行一个宏任务，并清空对应的微任务队列，每次事件循环完毕后会判断页面是否需要重新渲染 （大约16.6ms会渲染一次）
>

### 浏览器事件环
事件环是为了实现js的异步概念

js是“单线程” （主线程）的， 我们在写代码的时候 setTimeout  ajax

进程：计算机分配任务的最小单位  （不是按照线程分配的）

进程里包含多个线程 ，浏览器是由多个进程组成的



EventLoop解决的是 js执行时可能会调用异步方法，这些方法是怎样调度执行的

1.js执行的时候 会从上到下执行，遇到函数会创建执行上下文放入到执行栈中，执行完毕后会出栈 执行时可能会发生异步事件  - 》 内部会调用浏览器Api

2.当我们执行上下文栈都执行完毕后， 等会可能api执行完成或者时间到达， 会被我IE互道一个事件“队列”、消息“队列”  先进先出 

3.不停的扫描队列，将队列里的任务拿出来放到上下文栈中执行 

事件循环线程是专门干这件事的，检测当前执行栈是否为空，如果为空，从事件队列中取出一个来执行 setTimeout 宏任务

4.当代码执行时还会有一些任务 promise为例，微任务，每次执行宏任务的时候 都会单独创建一个微任务“队列” 先进先出

5.微任务在执行完毕后，浏览器会检测是否要重新渲染,浏览器有刷新频率 大约16.6ms

6.每次循环一次都会执行一个宏任务，并清空对应的微任务队列，每次循环完毕后，都要看是否要渲染，如果需要渲染才渲染

宏任务script脚本  界面渲染也是宏任务 setTimeout setInterval postMessage MessageChannel setImmediate也是宏任务  事件 ajax

微任务： promise.then mutationObserver 

微任务中在执行时再生成微任务，会在本轮直接清空

![](https://cdn.nlark.com/yuque/0/2021/png/804048/1629784179872-8f7f3005-7a75-4451-bb87-e4fdda175183.png)



## 面试题
### 微任务和GUI渲染
```html
<script>
        document.body.style.background = 'red';
        console.log(1)
        Promise.resolve().then(()=>{
            console.log(2)
            document.body.style.background = 'yellow';
        })
        console.log(3);
</script>

1 3 2 页面渲染直接是黄色
```

### 事件任务
```html
<button id="button">按钮</button>
<script>
        button.addEventListener('click',()=>{
            console.log('listener1');
            Promise.resolve().then(()=>console.log('micro task1'))
        })
        button.addEventListener('click',()=>{
            console.log('listener2');
            Promise.resolve().then(()=>console.log('micro task2'))
        })
        button.click(); // click1() click2()
</script>

// 通过js脚本执行的click触发的事件是同步的
// 相当于
// function fn1() {
//     console.log('listener1');
//     Promise.resolve().then(() => console.log('micro task1'))
// }
// function fn2() {
//     console.log('listener2');
//     Promise.resolve().then(() => console.log('micro task2'))
// }
// fn1();fn2()
// listener1 listener2 micro task1 micro task2
```

如果是用户触发的click事件，则是宏任务

```html
<button id="button">按钮</button>
<script>
  button.addEventListener('click', () => {
    console.log('listener1');
    Promise.resolve().then(() => console.log('micro task1'))
  })
  button.addEventListener('click', () => {
    console.log('listener2');
    Promise.resolve().then(() => console.log('micro task2'))
  })
  // 如果是用户触发的click事件，则是宏任务
  // listener1 micro task1 listener2 micro task2
</script>
```

### 定时器任务
```html
<script>
        Promise.resolve().then(() => {
            console.log('Promise1')
            setTimeout(() => {
                console.log('setTimeout2')
            }, 0);
        })
        setTimeout(() => {
            console.log('setTimeout1');
            Promise.resolve().then(() => {
                console.log('Promise2')
            })
        }, 0);
</script>
// Promise1 setTimeout1 Promise2 setTimeout2
```

### 任务执行面试题
```javascript
console.log(1);
async function async () {
    console.log(2);
    await console.log(3);
    console.log(4)
}
setTimeout(() => {
	console.log(5);
}, 0);
const promise = new Promise((resolve, reject) => {
    console.log(6);
    resolve(7)
})
promise.then(res => {
	console.log(res)
})
async (); 
console.log(8);

// 16238745
```

> 掌握Vue中nextTick原理
>

